# Chrome DevTools Agent Object Construction Guide

A strategic guide for agents using Chrome DevTools MCP to construct objects in the Banter VR platform.

**Last Updated**: 2025-10-13
**Purpose**: Ideological framework and practical patterns for object construction via JavaScript injection

---

## Table of Contents

1. [Philosophy & Strategy](#philosophy--strategy)
2. [Paradigm Selection Guide](#paradigm-selection-guide)
3. [Critical: Scripting vs UI Construction](#critical-scripting-vs-ui-construction)
4. [DECLARATIVE: Inventory-Based Construction](#declarative-inventory-based-construction)
5. [IMPERATIVE: Change Command Construction](#imperative-change-command-construction)
6. [Component Composition Patterns](#component-composition-patterns)
7. [Code Injection Templates](#code-injection-templates)
8. [Validation & Testing](#validation--testing)
9. [Common Pitfalls & Solutions](#common-pitfalls--solutions)
10. [Quick Reference](#quick-reference)

---

## Philosophy & Strategy

### The Two Programming Paradigms

When constructing objects via scripting, you have two fundamentally different approaches:

#### 1. DECLARATIVE APPROACH (What You Want)
**Method**: Create complete data structure → Save to inventory → Load to scene

```javascript
// Define WHAT you want as a complete specification
const objectSpec = {
  name: "MyObject",
  transform: { position: {x:0, y:1, z:0} },
  components: [/* all components */]
};
// Save it, then load it
```

**Philosophy**: "Describe the desired end state"
- You define the complete object structure upfront
- Single atomic operation when loading
- Object is either fully created or not at all
- Natural for templates and reusable prefabs

#### 2. IMPERATIVE APPROACH (How to Build It)
**Method**: Use global command functions to modify scene step-by-step

```javascript
// Define HOW to build it through sequential operations
// Note: Use global functions, NOT ChangeTypes.classes
let entity = await AddEntity("Scene", "MyObject", {context: 'script'});
await AddComponent(entity.id, "BanterBox", {context: 'script'});
let material = await AddComponent(entity.id, "BanterMaterial", {context: 'script'});
await SetComponentProp(material.id, "color", {r:1, g:0, b:0}, {context: 'script'})
await SetEntityProp(entity.id, "localPosition", {x:0, y:1, z:0}, {context: 'script'});
```

**Philosophy**: "Give instructions to construct"
- You issue commands that modify the scene directly
- Each operation happens immediately
- Can build conditionally based on results
- Natural for modifications and dynamic construction

### Core Principles for Scripted Construction

1. **Choose Your Paradigm First**
   - Declarative for known structures and templates
   - Imperative for dynamic building and modifications
   - Don't mix paradigms within a single construction task

2. **Explicit Declaration - No Magic**
   - Always pass `{context: 'script'}` to identify agent operations
   - When scripting, YOU must add EVERY component explicitly
   - No auto-imports or bundling happens in scripted construction
   - Component dependencies must be manually satisfied
   - This applies to BOTH paradigms

3. **Scripting vs UI Construction - Critical Difference**
   - **UI Construction**: Auto-imports dependencies with `{source: "ui"}`
   - **Scripted Construction**: NO auto-imports, all components must be explicit
   - Example: BanterGeometry needs BanterMaterial? You must add BOTH
   - Example: Need collision events? Must explicitly add BanterColliderEvents

4. **Transform is Special**
   - Transform is NOT a component anymore in the new format
   - Transform data lives at the entity level
   - Auto-generated by the system when entity is created

5. **Always Verify Construction**
   - Check entity exists: `SM.getEntityById(path)`
   - Check component added: `SM.getEntityComponentById(componentId)`
   - Verify all required components are present
   - Validate via snapshot: `mcp__chrome-devtools__take_snapshot()`

---

## Paradigm Selection Guide

### When to Use Each Approach

| Use Case | DECLARATIVE (Inventory) | IMPERATIVE (Change Commands) |
|----------|-------------------------|------------------------------|
| **Creating known structures** | ✅ Best choice | ❌ Verbose |
| **Building templates/prefabs** | ✅ Best choice | ❌ Not reusable |
| **Modifying existing objects** | ❌ Can't modify | ✅ Best choice |
| **Conditional construction** | ❌ All or nothing | ✅ Best choice |
| **Batch creation with variations** | ❌ Requires multiple saves | ✅ Best choice |
| **Runtime generation** | ❌ Overhead of save/load | ✅ Best choice |
| **Collaborative/shared objects** | ✅ Best choice | ❌ No persistence |
| **Version control needed** | ✅ Has history | ❌ No history |
| **Atomic operations required** | ✅ All or nothing | ❌ Partial states possible |
| **Learning from examples** | ✅ Complete structure visible | ❌ Must trace operations |

### Decision Matrix

```
START: What are you building?
    │
    ├─ A complete object with known structure?
    │   └─ DECLARATIVE → Define data, save to inventory, load
    │
    ├─ Modifying something that already exists?
    │   └─ IMPERATIVE → Use Change commands directly
    │
    ├─ Building dynamically based on conditions?
    │   └─ IMPERATIVE → Use Change commands with logic
    │
    ├─ Creating a reusable template/prefab?
    │   └─ DECLARATIVE → Save to inventory for reuse
    │
    └─ Experimenting/prototyping?
        ├─ Will you reuse it? → DECLARATIVE
        └─ Just testing? → IMPERATIVE
```

### The Definitive Rule

**Use DECLARATIVE when you know WHAT you want.**
**Use IMPERATIVE when you need to control HOW it's built.**

---

## Critical: Scripting vs UI Construction

### The Fundamental Difference

When constructing objects in Banter, there are two contexts:

1. **UI Context** (`{source: "ui"}`)
   - Used when humans click buttons in the Inspector UI
   - Auto-imports dependent components for convenience
   - Example: Adding BanterGeometry auto-adds BanterMaterial
   - Example: Adding BoxCollider might auto-add BanterColliderEvents
   - Designed for user-friendly manual building

2. **Scripting Context** (default)
   - Used when injecting JavaScript via Chrome DevTools
   - NO auto-imports - you get exactly what you specify
   - Full control and full responsibility
   - Must explicitly add ALL components you need

### Why This Matters for Agents

As a Chrome DevTools agent, you are ALWAYS in the **scripting context**. This means:

```javascript
// ❌ WRONG ASSUMPTION: "BanterBox will auto-include BanterMaterial"
await AddComponent(entityId, "BanterBox");
// Result: Box with NO material (invisible/default)

// ✅ CORRECT: Explicitly add both components
await AddComponent(entityId, "BanterBox");
await AddComponent(entityId, "BanterMaterial");
// Result: Box with material as intended
```

### Component Dependency Reference

When scripting, you must manually satisfy these common dependencies:

| Primary Component | Required Dependencies | Optional Enhancements |
|------------------|----------------------|----------------------|
| **BanterGeometry** | BanterMaterial | - |
| **BanterBox/Sphere/etc** | BanterMaterial | - |
| **BanterGrabbable** | Collider (Box/Sphere/etc), BanterRigidbody | BanterHeldEvents |
| **BanterRigidbody** | Collider (Box/Sphere/etc) | BanterPhysicMaterial |
| **Colliders** | - | BanterColliderEvents (for triggers) |
| **BanterText** | BanterMaterial | - |
| **Joints** | BanterRigidbody on both entities | - |

### Example: Building a Grabbable Cube

**UI Context (what a human would experience):**
1. Add BanterBox → Material auto-added
2. Add BanterGrabbable → Collider and Rigidbody auto-added
3. Done!

**Scripting Context (what you must do):**
```javascript
// Must explicitly add ALL components
const components = [
  { type: "BanterBox" },           // The mesh
  { type: "BanterMaterial" },      // Must add explicitly!
  { type: "BoxCollider" },         // Must add explicitly!
  { type: "BanterRigidbody" },     // Must add explicitly!
  { type: "BanterGrabbable" }      // Finally, the grab behavior
];
```

### The Scripting Mindset

**"Explicit is better than implicit"** - When scripting:
- Assume nothing is automatic
- Add every component you need
- Verify each component was added
- Check dependencies are satisfied

This gives you complete control but requires complete specification.

---

## DECLARATIVE: Inventory-Based Construction

### Philosophy: "Define WHAT You Want"
This paradigm is about describing the complete desired state as a data structure, then materializing it atomically.

### When to Use
- **Known structures**: You know exactly what the final object should be
- **Templates/Prefabs**: Creating reusable object definitions
- **Complex objects**: Multi-component structures that should be created atomically
- **Persistence needed**: Objects that must survive across sessions
- **Version control**: Need history tracking and rollback capabilities
- **Shared objects**: Multiple agents/users need the same object definition

### Step-by-Step Process

#### 1. Construct the Entity Data Structure

```javascript
// Basic entity structure (NEW FORMAT - no Transform component)
const entityData = {
  name: "MyCustomObject",
  active: true,
  layer: 0,  // Default layer
  persistent: true,

  // Transform at entity level (NOT as component)
  transform: {
    localPosition: { x: 0, y: 1, z: 0 },
    localRotation: { x: 0, y: 0, z: 0, w: 1 },
    localScale: { x: 1, y: 1, z: 1 }
  },

  // Components array
  components: [
    // Add components here (see patterns below)
  ]
};
```

#### 2. Add Components to the Entity

```javascript
// Example: Box with material
entityData.components = [
  {
    type: "BanterBox",
    properties: {
      // Box is a simplified geometry type
    }
  },
  {
    type: "BanterMaterial",
    properties: {
      color: { r: 1, g: 0.5, b: 0.2, a: 1 },
      shaderName: "Unlit/Diffuse",
      generateMipMaps: true,
      side: 0
    }
  }
];

// Example: GLTF model with grabbable behavior
entityData.components = [
  {
    type: "BanterGLTF",
    properties: {
      url: "https://your-cdn.com/model.glb",
      addColliders: true,
      nonConvexColliders: false,
      legacyRotate: false
    }
  },
  {
    type: "BanterGrabbable"
  }
];
```

#### 3. Create Inventory Item Structure

```javascript
const inventoryItem = {
  author: SM.scene?.localUser?.name || 'Agent',
  name: "MyCustomObject",
  created: Date.now(),
  last_used: Date.now(),
  itemType: "entity",
  icon: "📦",
  description: "Custom object created by agent",
  data: entityData,
  folder: null  // or specify folder name
};
```

#### 4. Save to Inventory

```javascript
// Method A: Using SetItem global function
await mcp__chrome-devtools__evaluate_script({
  function: `async () => {
    const inventoryItem = ${JSON.stringify(inventoryItem)};
    const result = await SetItem(inventoryItem, { context: 'script' });
    return {
      success: result !== null,
      itemName: inventoryItem.name
    };
  }`
});

// Method B: Using SaveEntityItem global function (if entity exists in scene)
await mcp__chrome-devtools__evaluate_script({
  function: `async () => {
    const entityId = "Scene/TempEntity";  // Must exist
    const itemName = "MyCustomObject";
    const folder = null;  // root folder

    // Use global function, not Change class
    const result = await SaveEntityItem(
      entityId, itemName, folder, { context: 'script' }
    );
    return { success: result !== null, itemName };
  }`
});
```

#### 5. Load from Inventory to Scene

```javascript
await mcp__chrome-devtools__evaluate_script({
  function: `async () => {
    const itemName = "MyCustomObject";
    const parentId = "Scene";  // or specific parent path

    // Use global function, not Change class
    const entity = await LoadItem(
      itemName, parentId, null, { context: 'script' }
    );
    return {
      success: entity !== null,
      entityId: entity?.id
    };
  }`
});
```

---

## IMPERATIVE: Change Command Construction

### Philosophy: "Define HOW to Build It"
This paradigm is about issuing sequential commands that progressively build or modify objects in the scene.

### When to Use
- **Modifying existing objects**: Changing properties or adding components to existing entities
- **Dynamic construction**: Building based on runtime conditions or user input
- **Iterative building**: Creating objects step-by-step with validation between steps
- **Batch operations with variations**: Creating multiple similar objects with differences
- **Quick experiments**: Rapid prototyping without saving to inventory
- **Conditional logic**: When construction depends on intermediate results

### Step-by-Step Process

#### 1. Create Entity

```javascript
await mcp__chrome-devtools__evaluate_script({
  function: `async () => {
    const parentId = "Scene";
    const entityName = "TestCube_1234";

    // Use global function, not Change class
    const entity = await AddEntity(
      parentId, entityName, { context: 'script' }
    );

    return {
      success: entity !== null,
      entityId: entity?.id
    };
  }`
});
```

#### 2. Add Components

```javascript
// Add a box mesh
await mcp__chrome-devtools__evaluate_script({
  function: `async () => {
    const entityId = "Scene/TestCube_1234";  // Use actual entity ID

    // Use global function
    const component = await AddComponent(
      entityId, "BanterBox", { context: 'script' }
    );

    return {
      success: component !== null,
      componentId: component?.id
    };
  }`
});

// Add material (REQUIRED for visibility - not auto-included in script context!)
await mcp__chrome-devtools__evaluate_script({
  function: `async () => {
    const entityId = "Scene/TestCube_1234";

    // Use global function with initial properties
    const component = await AddComponent(
      entityId,
      "BanterMaterial",
      {
        componentProperties:{
          color: { r: 0.2, g: 0.5, b: 1, a: 1 } 
        },
        context: 'script'
      }
    );

    return {
      success: component !== null,
      componentId: component?.id
    };
  }`
});
```

#### 3. Modify Properties

```javascript
// Set entity position
await mcp__chrome-devtools__evaluate_script({
  function: `async () => {
    const entityId = "Scene/TestCube_1234";
    const newPosition = { x: 2, y: 1, z: -3 };

    // Use global function
    await SetEntityProp(
      entityId, "localPosition", newPosition, { context: 'script' }
    );

    return { success: true };
  }`
});

// Set component property
await mcp__chrome-devtools__evaluate_script({
  function: `async () => {
    const componentId = "BanterMaterial_12345";  // Actual component ID
    const newColor = { r: 1, g: 0, b: 0, a: 1 };

    // Use global function
    await SetComponentProp(
      componentId, "color", newColor, { context: 'script' }
    );

    return { success: true };
  }`
});
```

---

## Paradigm Comparison: Same Object, Two Approaches

Let's build the same grabbable cube using both paradigms to illustrate the fundamental difference:

### The Object: A Red Grabbable Cube at Position (2, 1, 0)

#### DECLARATIVE Approach

```javascript
// 1. Define the complete structure
const grabbableCube = {
  name: "RedGrabbableCube",
  author: "Agent",
  created: Date.now(),
  last_used: Date.now(),
  itemType: "entity",
  data: {
    active: true,
    layer: 0,
    transform: {
      localPosition: { x: 2, y: 1, z: 0 },
      localRotation: { x: 0, y: 0, z: 0, w: 1 },
      localScale: { x: 1, y: 1, z: 1 }
    },
    components: [
      { type: "BanterBox" },
      {
        type: "BanterMaterial",
        properties: { color: { r: 1, g: 0, b: 0, a: 1 } }
      },
      { type: "BoxCollider" },
      {
        type: "BanterRigidbody",
        properties: { mass: 1, useGravity: true }
      },
      {
        type: "BanterGrabbable"
      }
    ]
  }
};

// 2. Save to inventory using SetItem global function
await SetItem(grabbableCube, {context: 'script'});

// 3. Load to scene using global function
await LoadItem("RedGrabbableCube", "Scene", null, {context: 'script'});
```

#### IMPERATIVE Approach

```javascript
// Use global functions, not Change classes!

// 1. Create entity
const entity = await AddEntity("Scene", "RedGrabbableCube", {context: 'script'});

// 2. Add box mesh
await AddComponent(entity.id, "BanterBox", {context: 'script'});

// 3. Add material with red color (REQUIRED!)
await AddComponent(
  entity.id,
  "BanterMaterial",
  {
    context: 'script',
    color: { r: 1, g: 0, b: 0, a: 1 }
  }
);

// 4. Add collider for physics
await AddComponent(entity.id, "BoxCollider", {context: 'script'});

// 5. Add rigidbody for grabbable
await AddComponent(
  entity.id,
  "BanterRigidbody",
  {
    context: 'script',
    mass: 1,
    useGravity: true
  }
);

// 6. Add grabbable component
await AddComponent(
  entity.id,
  "BanterGrabbable",
  {
    context: 'script'
  }
);

// 7. Set position
await SetEntityProp(
  entity.id,
  "localPosition",
  { x: 2, y: 1, z: 0 },
  {context: 'script'}
);
```

### Key Differences Illustrated

| Aspect | DECLARATIVE | IMPERATIVE |
|--------|------------|------------|
| **Lines of code** | ~30 (mostly data) | ~25 (mostly operations) |
| **Operations** | 3 (define, save, load) | 7+ sequential commands |
| **Error handling** | Single point of failure | Multiple failure points |
| **Partial states** | Impossible (atomic) | Possible between commands |
| **Reusability** | Saved in inventory | Must re-run all commands |
| **Modification** | Replace entire structure | Add/change specific parts |
| **Debugging** | Inspect data structure | Trace command sequence |

### When Each Shines

**DECLARATIVE shines when:**
- You're defining a complete "prefab" or template
- The structure is known and fixed
- You want to share or reuse the object
- Atomic creation is important

**IMPERATIVE shines when:**
- You need to add components conditionally
- You're modifying an existing object
- Building interactively based on results
- Creating many variations programmatically

---

## Component Composition Patterns

**IMPORTANT**: All patterns show EVERY required component. When scripting, nothing is auto-added!

### Basic Primitive (Box/Sphere/Cylinder)

```javascript
{
  components: [
    { type: "BanterBox" },  // or BanterSphere, BanterCylinder
    {
      type: "BanterMaterial",  // MUST be explicitly added for visibility!
      properties: {
        color: { r: 1, g: 1, b: 1, a: 1 },
        shaderName: "Unlit/Diffuse",
        generateMipMaps: true,
        side: 0  // 0=Front, 1=Back, 2=Double
      }
    }
  ]
}
```

### Interactive Object (Grabbable)

```javascript
{
  components: [
    { type: "BanterBox" },            // The visual mesh
    { type: "BanterMaterial" },       // Required for visibility
    { type: "BoxCollider" },          // Required for physics/grabbing
    {
      type: "BanterRigidbody",        // Required for grabbable
      properties: {
        mass: 1,
        drag: 0.5,
        angularDrag: 0.5,
        useGravity: true
      }
    },
    { type: "BanterGrabbable" }       // The grab behavior itself
  ]
}
```

### GLTF Model with Scripts

```javascript
{
  components: [
    {
      type: "BanterGLTF",
      properties: {
        url: "https://cdn.example.com/model.glb",
        addColliders: true
      }
    },
    {
      type: "MonoBehavior",
      properties: {
        file: "CustomBehavior.js",
        vars: {
          speed: 1.0,
          enabled: true
        }
      }
    }
  ]
}
```

### Physics Object

```javascript
{
  components: [
    { type: "BanterSphere" },
    { type: "BanterMaterial" },
    { type: "SphereCollider" },
    {
      type: "BanterRigidbody",
      properties: {
        mass: 0.5,
        drag: 0.1,
        angularDrag: 0.05,
        useGravity: true
      }
    },
    {
      type: "BanterPhysicMaterial",
      properties: {
        bounciness: 0.8,
        frictionCombine: 0,
        bounceCombine: 3
      }
    }
  ]
}
```

### UI Panel

```javascript
{
  components: [
    {
      type: "BanterUIPanel",
      properties: {
        width: 400,
        height: 300,
        content: "<h1>Hello VR</h1><p>Interactive UI</p>"
      }
    },
    { type: "BoxCollider" }
  ]
}
```

---

## Code Injection Templates

### Template 1: Quick Primitive Creation (WITH Material!)

```javascript
// Complete primitive creation flow - INCLUDES REQUIRED MATERIAL
await mcp__chrome-devtools__evaluate_script({
  function: `async () => {
    // 1. Create entity using global function
    const entityName = "Cube_" + Date.now();
    const entity = await window.AddEntity(
      "Scene", entityName, { context: 'script' }
    );

    if (!entity) return { error: "Failed to create entity" };

    // 2. Add box component
    await window.AddComponent(
      entity.id, "BanterBox", { context: 'script' }
    );

    // 3. CRITICAL: Add material (required for visibility!)
    await window.AddComponent(
      entity.id,
      "BanterMaterial",
      {
        context: 'script',
        color: { r: 1, g: 0.5, b: 0.2, a: 1 },
        shaderName: "Unlit/Diffuse"
      }
    );

    // 4. Set position
    await window.SetEntityProp(
      entity.id, "localPosition", { x: 0, y: 2, z: 0 }, { context: 'script' }
    );

    return {
      success: true,
      entityId: entity.id,
      message: "Created box with material at (0, 2, 0)"
    };
  }`
});
```

### Template 2: Batch Object Creation (WITH Materials!)

```javascript
// Create multiple objects in a grid - ALL WITH MATERIALS
await mcp__chrome-devtools__evaluate_script({
  function: `async () => {
    const results = [];

    for (let x = 0; x < 3; x++) {
      for (let z = 0; z < 3; z++) {
        const name = \`GridObj_\${x}_\${z}\`;

        // Create entity using global function
        const entity = await window.AddEntity(
          "Scene", name, { context: 'script' }
        );

        if (entity) {
          // Add sphere
          await window.AddComponent(
            entity.id, "BanterSphere", { context: 'script' }
          );

          // CRITICAL: Add material with unique color per object
          await window.AddComponent(
            entity.id,
            "BanterMaterial",
            {
              context: 'script',
              color: {
                r: x / 2,      // Vary red by x position
                g: 0.5,
                b: z / 2,      // Vary blue by z position
                a: 1
              }
            }
          );

          // Position in grid
          await window.SetEntityProp(
            entity.id,
            "localPosition",
            { x: x * 2, y: 1, z: z * 2 },
            { context: 'script' }
          );

          results.push(entity.id);
        }
      }
    }

    return {
      success: true,
      created: results.length,
      entities: results,
      message: "Created grid of spheres with varied colors"
    };
  }`
});
```

### Template 3: Save Current Selection to Inventory

```javascript
// Save whatever is currently selected
await mcp__chrome-devtools__evaluate_script({
  function: `async () => {
    const selectedEntity = SM.selectedEntity;

    if (!selectedEntity) {
      return { error: "No entity selected" };
    }

    const itemName = selectedEntity.name + "_saved";

    // Use global function, not Change class
    const result = await window.SaveEntityItem(
      selectedEntity.id,
      itemName,
      null,  // root folder
      { context: 'script' }
    );

    return {
      success: result !== null,
      itemName: itemName,
      message: result ?
        \`Saved \${selectedEntity.name} to inventory as \${itemName}\` :
        "Failed to save entity"
    };
  }`
});
```

---

## Validation & Testing

### 1. Verify Entity Creation

```javascript
await mcp__chrome-devtools__evaluate_script({
  function: `() => {
    const entityId = "Scene/MyEntity";
    const entity = SM.getEntityById(entityId);

    return {
      exists: entity !== undefined,
      isActive: entity?.active,
      hasComponents: entity?.components?.length > 0,
      componentCount: entity?.components?.length || 0,
      componentTypes: entity?.components?.map(c => c.type) || []
    };
  }`
});
```

### 2. Check Component Properties

```javascript
await mcp__chrome-devtools__evaluate_script({
  function: `() => {
    const componentId = "BanterMaterial_12345";
    const component = SM.getEntityComponentById(componentId);

    return {
      exists: component !== undefined,
      type: component?.type,
      properties: component?.properties,
      initialized: component?._initialized
    };
  }`
});
```

### 3. Validate Inventory Item

```javascript
await mcp__chrome-devtools__evaluate_script({
  function: `() => {
    const itemName = "MyCustomObject";
    const item = inventory.items[itemName];

    return {
      exists: item !== undefined,
      type: item?.itemType,
      hasData: item?.data !== undefined,
      componentCount: item?.data?.components?.length || 0,
      author: item?.author,
      created: item?.created ? new Date(item.created).toISOString() : null
    };
  }`
});
```

### 4. Take Visual Snapshot

```javascript
// Use MCP to verify visually
await mcp__chrome-devtools__take_snapshot();
// Look for your entity in the hierarchy
```

---

## Common Pitfalls & Solutions

### Pitfall 1: Transform Component in New Format

**Wrong:**
```javascript
components: [
  {
    type: "Transform",  // ❌ Transform is NOT a component
    properties: { localPosition: { x: 1, y: 2, z: 3 } }
  }
]
```

**Correct:**
```javascript
{
  transform: {  // ✅ Transform at entity level
    localPosition: { x: 1, y: 2, z: 3 },
    localRotation: { x: 0, y: 0, z: 0, w: 1 },
    localScale: { x: 1, y: 1, z: 1 }
  },
  components: [
    // Other components here
  ]
}
```

### Pitfall 2: Missing Component IDs

**Problem:** Components need unique IDs for tracking
**Solution:** Let the system auto-generate them or provide unique ones

```javascript
// Let system generate
const change = new ComponentAddChange(entityId, componentType);

// Or provide your own
componentProperties: {
  id: `${componentType}_${Math.floor(Math.random() * 99999)}`
}
```

### Pitfall 3: Invalid Entity Paths

**Wrong:**
```javascript
"MyEntity"  // ❌ Missing parent path
```

**Correct:**
```javascript
"Scene/MyEntity"  // ✅ Full hierarchical path
"Scene/Parent/Child"  // ✅ Nested path
```

### Pitfall 4: Component Dependencies

**Problem:** Some components require others to function
**Solution:** Add required components or use bundled types

```javascript
// BanterGrabbable needs collider and rigidbody
components: [
  { type: "BanterBox" },
  { type: "BoxCollider" },  // Required for grabbing
  { type: "BanterRigidbody" },  // Required for physics
  { type: "BanterGrabbable" }
]
```

### Pitfall 5: Async Operation Timing

**Problem:** Operations may not complete immediately
**Solution:** Always await changes and verify

```javascript
const change = new EntityAddChange(parentId, name);
const entity = await change.apply();  // Wait for completion

// Verify before proceeding
if (!entity) {
  throw new Error("Entity creation failed");
}
```

---

## Quick Reference

### Essential Global Objects & Functions

```javascript
// Scene Management
SM                    // Scene Manager
SM.scene             // BanterScript scene
SM.getEntityById()   // Get entity by path
SM.selectedEntity    // Currently selected
scene                // Unity scene object
scene.objects        // All GameObjects
scene.spaceState     // Space properties

// Global Command Functions (Use these, not ChangeTypes.classes!)
AddEntity(parentId, name, options)           // Create entity
RemoveEntity(entityId, options)              // Delete entity
MoveEntity(entityId, newParentId, options)   // Move entity
CloneEntity(entityId, options)               // Clone entity
SetEntityProp(entityId, prop, value, options) // Set entity property

AddComponent(entityId, componentType, options)    // Add component
RemoveComponent(componentId, options)             // Remove component
SetComponentProp(componentId, prop, value, options) // Set component property

SetItem(itemData, options)                          // Save item to inventory (NEW!)
SaveEntityItem(entityId, itemName, folder, options) // Save entity to inventory
LoadItem(itemName, parentId, position, options)     // Load from inventory
DeleteItem(itemName, options)                       // Delete from inventory

SetSpaceProp(prop, value, isProtected, options)     // Set space property

// Support Systems
inventory            // Inventory system
inventory.items      // All saved items
ComponentRegistry    // Component definitions
ComponentRegistry.list()
ComponentRegistry.getByCategory()

// Always pass {context: 'script'} in options!
```

### Common Component Types

**Geometry/Meshes:**
- `BanterBox`, `BanterSphere`, `BanterCylinder`, `BanterPlane`
- `BanterTorus`, `BanterCone`, `BanterRing`
- `BanterText` - 3D text
- `BanterGeometry` - Generic geometry with parameters

**Materials:**
- `BanterMaterial` - Visual material
- `BanterPhysicMaterial` - Physics properties

**Physics:**
- `BanterRigidbody` - Physics simulation
- `BoxCollider`, `SphereCollider`, `CapsuleCollider`, `MeshCollider`
- Joints: `HingeJoint`, `FixedJoint`, `SpringJoint`, `ConfigurableJoint`

**Behaviors:**
- `BanterGrabbable` - VR grabbable
- `BanterSyncedObject` - Multi-user sync
- `BanterColliderEvents` - Collision detection
- `MonoBehavior` - Custom scripts

**Media:**
- `BanterGLTF` - 3D models
- `BanterAudioSource` - Sound playback
- `BanterVideoPlayer` - Video playback

**Special:**
- `BanterMirror` - Reflective surface
- `BanterPortal` - Teleport portal
- `BanterUIPanel` - HTML UI
- `BanterBrowser` - Web browser

### Important Note on Methods

**For Chrome DevTools agents:**
- Use global functions like `AddEntity()`, `AddComponent()`, etc.
- Do NOT use `ChangeTypes.classes.*` - those are for internal undo/redo
- Always pass `{context: 'script'}` to identify agent operations

**Shell commands (for reference only):**
```
These are typed directly in the inspector shell, not used in scripts:
add_entity Scene MyEntity
remove_entity Scene/MyEntity
add_component Scene/Entity BanterBox
set_entity_property Scene/Entity localPosition {x:0,y:1,z:0}
```

---

## Best Practices Summary

1. **EXPLICITLY ADD ALL COMPONENTS** - When scripting, nothing is automatic!
2. **Always add BanterMaterial with geometry** - Without it, objects are invisible
3. **Validate before proceeding** - Check entities exist before adding components
4. **Use inventory for complex objects** - Easier to manage and reuse
5. **Let system generate IDs** - Avoid ID conflicts
6. **Understand component dependencies** - Must manually satisfy all dependencies
7. **Use proper paths** - Always include parent in entity paths (Scene/Entity)
8. **Await async operations** - Ensure changes complete before continuing
9. **Test incrementally** - Build objects step by step, validating each stage
10. **Use visual verification** - Take snapshots to confirm construction
11. **Handle errors gracefully** - Check return values and handle failures
12. **Document your objects** - Add descriptions to inventory items

---

## Conclusion

This guide establishes a paradigm-first approach to object construction in the Banter VR platform.

### The Fundamental Choice

Before writing any code, you must choose your paradigm:

**DECLARATIVE (Inventory)**
- "I want to describe WHAT should exist"
- Best for: Templates, prefabs, known structures
- Approach: Define → Save → Load

**IMPERATIVE (Change Commands)**
- "I want to control HOW it's built"
- Best for: Modifications, dynamic construction, experiments
- Approach: Command → Command → Command

### The Five Universal Truths

1. **Use global functions, not Change classes** - `AddEntity()` not `ChangeTypes.classes.EntityAddChange`
2. **Choose your paradigm FIRST** - Don't mix approaches in a single task
3. **Explicit is non-negotiable** - When scripting, YOU add EVERY component
4. **No auto-imports in scripting** - The `{source: "ui"}` magic is UI-only
5. **Materials are mandatory** - Geometry without BanterMaterial = invisible

### Decision Framework

```
Are you building something new?
  → Do you know the complete structure? → DECLARATIVE
  → Do you need to build conditionally? → IMPERATIVE

Are you modifying something?
  → IMPERATIVE (no other choice)

Are you creating templates?
  → DECLARATIVE (for reusability)

Are you experimenting?
  → Will you reuse it? → DECLARATIVE
  → Just testing? → IMPERATIVE
```

### Final Word

Three critical implementation rules for Chrome DevTools agents:

1. **Always use global functions** (`AddEntity`, `AddComponent`, etc.) - never the Change classes
2. **Always pass `{context: 'script'}`** in the options parameter
3. **Always add all components explicitly** - nothing is automatic in script context

The distinction between declarative and imperative construction is not about complexity or simplicity - it's about whether you're defining an end state or a process. Master both paradigms, choose deliberately, and execute with precision.

**Remember: In scripting, you have complete control and complete responsibility.**