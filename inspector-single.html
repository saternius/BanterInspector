<!DOCTYPE html>
<!--
Unity Scene Inspector
===================

This inspector connects to Unity via the BS (BanterScript) library to display real-time scene hierarchy and component data.

Requirements:
1. The BS library must be loaded (typically from dist/bundle.js)
2. Unity must be running with the BS bridge active
3. The scene must have accessible GameObjects

If the BS library integration doesn't work, you may need to:

1. Ensure the BS library is properly injected into Unity:
   - Check that window.BS is available
   - Verify BS.BanterScene.GetInstance() returns a valid scene object
   - Confirm the "unity-loaded" event fires

2. Add additional scene discovery methods:
   - The current implementation looks for common root object names
   - You may need to add custom root object names specific to your scene
   - Consider implementing a scene registration system where objects register themselves

3. Extend component type support:
   - Add more BS.ComponentType checks in the extractComponentData function
   - Map Unity component types to their BS equivalents
   - Handle custom components specific to your project

4. Implement bi-directional updates:
   - Currently read-only, but could add property setters
   - Use BS component methods to update values in Unity
   - Add event listeners for Unity-side changes

5. Handle edge cases:
   - Circular references in the hierarchy
   - Very large scenes (implement pagination/lazy loading)
   - Dynamic object creation/destruction
   - Network-synced objects

The inspector will fall back to mock data if it cannot connect to Unity.
-->
<html lang="en" android-bundle windows-bundle>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Unity Scene Inspector - Resonite Style</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #121212;
            color: #e8e8e8;
            height: 100vh;
            overflow: hidden;
            font-size: 14px;
        }

        .inspector-container {
            display: flex;
            height: 100vh;
            gap: 1px;
            background: #0a0a0a;
        }

        /* Panel Base Styles */
        .panel {
            background: #1a1a1a;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .panel-header {
            background: #242424;
            padding: 10px 15px;
            border-bottom: 1px solid #2a2a2a;
            font-weight: 600;
            font-size: 13px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #b8b8b8;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        /* Hierarchy Panel */
        .hierarchy-panel {
            width: 320px;
            flex-shrink: 0;
        }

        .search-container {
            padding: 8px;
            background: #1a1a1a;
            border-bottom: 1px solid #2a2a2a;
        }

        .search-input {
            width: 100%;
            background: #0f0f0f;
            border: 1px solid #2a2a2a;
            border-radius: 4px;
            padding: 6px 10px;
            color: #e8e8e8;
            font-size: 13px;
        }

        .search-input:focus {
            outline: none;
            border-color: #4a4a4a;
            background: #161616;
        }

        .slot-actions-container {
            padding: 8px;
            background: #1a1a1a;
            border-bottom: 1px solid #2a2a2a;
            display: flex;
            gap: 8px;
        }

        .action-button {
            flex: 1;
            background: #2a2a2a;
            border: 1px solid #333;
            border-radius: 4px;
            padding: 6px 12px;
            color: #e8e8e8;
            font-size: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
            transition: all 0.2s ease;
        }

        .action-button:hover {
            background: #353535;
            border-color: #444;
        }

        .action-button:active {
            background: #202020;
        }

        .action-button.delete-button {
            background: #3a2020;
            border-color: #4a2525;
        }

        .action-button.delete-button:hover {
            background: #4a2525;
            border-color: #5a3030;
        }

        .button-icon {
            font-size: 16px;
            font-weight: bold;
        }

        /* Add Component Button */
        .add-component-container {
            padding: 12px;
            border-top: 1px solid #2a2a2a;
            background: #1a1a1a;
        }

        .add-component-button {
            width: 100%;
            background: #2a2a2a;
            border: 1px solid #333;
            border-radius: 4px;
            padding: 8px 16px;
            color: #e8e8e8;
            font-size: 13px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            transition: all 0.2s ease;
        }

        .add-component-button:hover {
            background: #353535;
            border-color: #444;
        }

        .add-component-button:active {
            background: #202020;
        }

        .hierarchy-tree {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 4px 0;
        }

        /* Tree Node Styles */
        .tree-node {
            display: flex;
            align-items: center;
            padding: 3px 8px;
            cursor: pointer;
            user-select: none;
            min-height: 24px;
            position: relative;
        }

        .tree-node:hover {
            background: #252525;
        }

        .tree-node.selected {
            background: #2a2a2a;
        }

        .tree-node.selected > .node-content > .node-name {
            color: #ffd700;
            font-weight: 500;
        }

        .tree-node.non-persistent > .node-content > .node-name {
            color: #ff9500;
        }
        
        .tree-node.inactive > .node-content > .node-name {
            color: #666;
            font-style: italic;
        }
        
        .tree-node.inactive > .node-content > .node-icon {
            background: #444;
        }

        .node-content {
            display: flex;
            align-items: center;
            flex: 1;
            overflow: hidden;
        }

        .tree-toggle {
            width: 16px;
            height: 16px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            color: #888;
            font-size: 10px;
            flex-shrink: 0;
        }

        .tree-toggle:hover {
            color: #b8b8b8;
        }

        .tree-toggle.has-children {
            cursor: pointer;
        }

        .tree-toggle.empty {
            color: #555;
        }

        .node-icon {
            width: 4px;
            height: 4px;
            background: #888;
            border-radius: 50%;
            margin: 0 8px;
            flex-shrink: 0;
        }

        .node-name {
            color: #e8e8e8;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .tree-children {
            margin-left: 20px;
        }

        /* Properties Panel */
        .properties-panel {
            flex: 1;
            min-width: 400px;
        }
        
        /* Space Props Panel */
        .space-props-panel {
            width: 480px;
            flex-shrink: 0;
            border-left: 1px solid #2a2a2a;
        }

        .properties-content {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 12px;
        }

        /* Component Styles */
        .component-section {
            background: #1f1f1f;
            border: 1px solid #2a2a2a;
            border-radius: 6px;
            margin-bottom: 10px;
            overflow: hidden;
        }

        .component-header {
            background: #242424;
            padding: 8px 12px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
            border-bottom: 1px solid #2a2a2a;
        }

        .component-header:hover {
            background: #2a2a2a;
        }

        .component-name {
            font-weight: 500;
            font-size: 13px;
            color: #e8e8e8;
        }

        .component-type {
            font-size: 11px;
            color: #888;
            margin-left: 8px;
        }

        .component-toggle {
            font-size: 10px;
            color: #888;
        }

        .component-body {
            padding: 8px 12px;
            background: #1a1a1a;
        }

        /* Property Styles */
        .property-row {
            display: flex;
            align-items: center;
            padding: 5px 0;
            min-height: 28px;
        }

        .property-row + .property-row {
            border-top: 1px solid #252525;
        }

        .property-button {
            width: 20px;
            height: 20px;
            background: #2a2a2a;
            border: 1px solid #3a3a3a;
            border-radius: 3px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            margin-right: 8px;
            font-size: 11px;
            color: #888;
            flex-shrink: 0;
        }

        .property-button:hover {
            background: #333;
            border-color: #444;
            color: #b8b8b8;
        }

        .property-label {
            flex: 0 0 140px;
            font-size: 12px;
            color: #b8b8b8;
            padding-right: 8px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .property-value {
            flex: 1;
            display: flex;
            gap: 6px;
            align-items: center;
        }

        .property-input {
            background: #0f0f0f;
            border: 1px solid #2a2a2a;
            border-radius: 3px;
            padding: 4px 8px;
            color: #e8e8e8;
            font-size: 12px;
            font-family: 'Consolas', 'Monaco', monospace;
            flex: 1;
        }

        .property-input:focus {
            outline: none;
            border-color: #4a4a4a;
            background: #161616;
        }

        .property-input.number {
            width: 70px;
            flex: 0 0 70px;
            text-align: right;
        }

        /* Vector Input Styles */
        .vector-group {
            display: flex;
            gap: 4px;
            flex: 1;
            align-items: center;
        }

        .vector-label {
            font-size: 11px;
            color: #666;
            font-weight: 600;
            margin: 0 2px;
        }

        /* Color Input Styles */
        .color-group {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .color-preview {
            width: 32px;
            height: 24px;
            border-radius: 3px;
            border: 1px solid #3a3a3a;
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }

        .color-preview::before {
            content: '';
            position: absolute;
            inset: 0;
            background-image: 
                linear-gradient(45deg, #2a2a2a 25%, transparent 25%),
                linear-gradient(-45deg, #2a2a2a 25%, transparent 25%),
                linear-gradient(45deg, transparent 75%, #2a2a2a 75%),
                linear-gradient(-45deg, transparent 75%, #2a2a2a 75%);
            background-size: 8px 8px;
            background-position: 0 0, 0 4px, 4px -4px, -4px 0px;
        }

        .color-swatch {
            position: absolute;
            inset: 0;
        }

        /* Checkbox Styles */
        .checkbox-input {
            width: 18px;
            height: 18px;
            cursor: pointer;
            accent-color: #4a90e2;
        }

        /* Empty States */
        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: #666;
        }

        .empty-state h3 {
            font-size: 16px;
            font-weight: 500;
            margin-bottom: 8px;
            color: #888;
        }

        .empty-state p {
            font-size: 13px;
            color: #555;
        }

        /* Loading State */
        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 40px;
            color: #666;
        }

        .loading::before {
            content: '';
            width: 20px;
            height: 20px;
            border: 2px solid #333;
            border-top-color: #666;
            border-radius: 50%;
            margin-right: 10px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Scrollbar Styles */
        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }

        ::-webkit-scrollbar-track {
            background: #0f0f0f;
        }

        ::-webkit-scrollbar-thumb {
            background: #2a2a2a;
            border-radius: 5px;
            border: 1px solid #1a1a1a;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #3a3a3a;
        }

        /* Utility Classes */
        .grabbable {
            cursor: grab;
        }

        .grabbable:active {
            cursor: grabbing;
        }

        .tooltip {
            position: absolute;
            background: #2a2a2a;
            border: 1px solid #3a3a3a;
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 11px;
            color: #e8e8e8;
            pointer-events: none;
            z-index: 1000;
            white-space: nowrap;
        }
        
        /* Space Props Specific Styles */
        .props-content {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 12px;
        }
        
        .props-section {
            background: #1f1f1f;
            border: 1px solid #2a2a2a;
            border-radius: 6px;
            margin-bottom: 12px;
            overflow: hidden;
        }
        
        .props-section-header {
            background: #242424;
            padding: 10px 15px;
            border-bottom: 1px solid #2a2a2a;
            font-weight: 600;
            font-size: 13px;
            color: #e8e8e8;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .props-section-body {
            padding: 8px 12px;
            background: #1a1a1a;
        }
        
        .prop-item {
            display: flex;
            align-items: center;
            padding: 6px 0;
            min-height: 32px;
            border-bottom: 1px solid #252525;
        }
        
        .prop-item:last-child {
            border-bottom: none;
        }
        
        .prop-key {
            flex: 0 0 120px;
            font-size: 12px;
            color: #b8b8b8;
            padding-right: 12px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            font-family: 'Consolas', 'Monaco', monospace;
        }
        
        .prop-value {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .prop-input {
            flex: 1;
            background: #0f0f0f;
            border: 1px solid #2a2a2a;
            border-radius: 3px;
            padding: 5px 8px;
            color: #e8e8e8;
            font-size: 12px;
            font-family: 'Consolas', 'Monaco', monospace;
        }
        
        .prop-input:focus {
            outline: none;
            border-color: #4a4a4a;
            background: #161616;
        }
        
        .prop-input:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        
        .prop-actions {
            display: flex;
            gap: 4px;
        }
        
        .prop-button {
            width: 24px;
            height: 24px;
            background: #2a2a2a;
            border: 1px solid #3a3a3a;
            border-radius: 3px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 12px;
            color: #888;
            transition: all 0.2s;
        }
        
        .prop-button:hover {
            background: #333;
            border-color: #444;
            color: #b8b8b8;
        }
        
        .prop-button.save {
            color: #4a90e2;
        }
        
        .prop-button.delete {
            color: #e24a4a;
        }
        
        .prop-button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }
        
        .add-prop-container {
            display: flex;
            gap: 8px;
            padding: 8px 0;
            border-top: 1px solid #2a2a2a;
            margin-top: 8px;
        }
        
        .add-prop-input {
            flex: 1;
            background: #0f0f0f;
            border: 1px solid #2a2a2a;
            border-radius: 3px;
            padding: 5px 8px;
            color: #e8e8e8;
            font-size: 12px;
            font-family: 'Consolas', 'Monaco', monospace;
        }
        
        .add-prop-button {
            padding: 5px 12px;
            background: #2a2a2a;
            border: 1px solid #3a3a3a;
            border-radius: 3px;
            color: #b8b8b8;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .add-prop-button:hover {
            background: #333;
            border-color: #444;
            color: #e8e8e8;
        }
        
        .props-empty {
            text-align: center;
            padding: 20px;
            color: #666;
            font-size: 12px;
        }
        
        .props-badge {
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 3px;
            background: #2a2a2a;
            color: #888;
            margin-left: 8px;
        }

        /* Component Menu Styles */
        .component-menu-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            backdrop-filter: blur(4px);
        }

        .component-menu {
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 8px;
            width: 600px;
            max-width: 90vw;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        .component-menu-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 20px;
            border-bottom: 1px solid #2a2a2a;
        }

        .component-menu-header h2 {
            margin: 0;
            font-size: 18px;
            font-weight: 600;
            color: #e8e8e8;
        }

        .close-button {
            background: none;
            border: none;
            color: #888;
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            transition: all 0.2s ease;
        }

        .close-button:hover {
            background: #2a2a2a;
            color: #e8e8e8;
        }

        .component-menu-search {
            padding: 12px 20px;
            border-bottom: 1px solid #2a2a2a;
        }

        .component-search-input {
            width: 100%;
            background: #0f0f0f;
            border: 1px solid #2a2a2a;
            border-radius: 4px;
            padding: 8px 12px;
            color: #e8e8e8;
            font-size: 13px;
        }

        .component-search-input:focus {
            outline: none;
            border-color: #4a4a4a;
            background: #161616;
        }

        .component-menu-content {
            flex: 1;
            overflow-y: auto;
            padding: 12px;
        }

        .component-category {
            margin-bottom: 16px;
        }

        .category-header {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: #242424;
            border-radius: 4px;
            margin-bottom: 8px;
        }

        .category-icon {
            font-size: 16px;
        }

        .category-name {
            font-size: 13px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #b8b8b8;
        }

        .category-items {
            display: grid;
            gap: 4px;
        }

        .component-item {
            display: flex;
            flex-direction: column;
            padding: 10px 16px;
            background: #202020;
            border: 1px solid transparent;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .component-item:hover {
            background: #252525;
            border-color: #333;
        }

        .component-item.hidden {
            display: none;
        }

        .component-item-name {
            font-size: 14px;
            font-weight: 500;
            color: #e8e8e8;
            margin-bottom: 2px;
        }

        .component-item-desc {
            font-size: 12px;
            color: #888;
        }
    </style>
</head>
<body>
    <div class="inspector-container">
        <!-- Hierarchy Panel -->
        <div class="panel hierarchy-panel">
            <div class="panel-header">
                <span>Hierarchy</span>
            </div>
            <div class="search-container">
                <input type="text" class="search-input" placeholder="Search slots..." id="searchInput">
            </div>
            <div class="slot-actions-container">
                <button class="action-button" id="addChildSlotBtn" title="Add New Child Slot">
                    <span class="button-icon">+</span> Add Child Slot
                </button>
                <button class="action-button delete-button" id="deleteSlotBtn" title="Delete Selected Slot">
                    <span class="button-icon">Ã—</span> Delete Slot
                </button>
            </div>
            <div class="hierarchy-tree" id="hierarchyTree">
                <div class="loading">Loading scene...</div>
            </div>
        </div>

        <!-- Properties Panel -->
        <div class="panel properties-panel">
            <div class="panel-header">
                <span>Inspector</span>
            </div>
            <div class="properties-content" id="propertiesContent">
                <div class="empty-state">
                    <h3>No Slot Selected</h3>
                    <p>Select a slot from the hierarchy to inspect its components</p>
                </div>
            </div>
            <div class="add-component-container" id="addComponentContainer" style="display: none;">
                <button class="add-component-button" id="addComponentBtn">
                    <span class="button-icon">+</span> Add Component
                </button>
            </div>
        </div>
        
        <!-- Space Props Panel -->
        <div class="panel space-props-panel">
            <div class="panel-header">
                <span>Space Properties</span>
            </div>
            <div class="props-content" id="spacePropsContent">
                <!-- Public Space Props Section -->
                <div class="props-section" id="publicPropsSection">
                    <div class="props-section-header">
                        <span>Public Properties<span class="props-badge" id="publicPropsCount">0</span></span>
                    </div>
                    <div class="props-section-body">
                        <div id="publicPropsList" class="props-list">
                            <div class="props-empty">No public properties</div>
                        </div>
                        <div class="add-prop-container">
                            <input type="text" class="add-prop-input" id="addPublicKey" placeholder="Property key">
                            <input type="text" class="add-prop-input" id="addPublicValue" placeholder="Value">
                            <button class="add-prop-button" onclick="addPublicProp()">Add</button>
                        </div>
                    </div>
                </div>
                
                <!-- Protected Space Props Section -->
                <div class="props-section" id="protectedPropsSection">
                    <div class="props-section-header">
                        <span>Protected Properties<span class="props-badge" id="protectedPropsCount">0</span></span>
                    </div>
                    <div class="props-section-body">
                        <div id="protectedPropsList" class="props-list">
                            <div class="props-empty">No protected properties</div>
                        </div>
                        <div class="add-prop-container">
                            <input type="text" class="add-prop-input" id="addProtectedKey" placeholder="Property key">
                            <input type="text" class="add-prop-input" id="addProtectedValue" placeholder="Value">
                            <button class="add-prop-button" onclick="addProtectedProp()">Add</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Load the BS library if available -->
    <!-- <script src="dist/bundle.js"></script> -->
    
    <script>
        // Inspector state
        let sceneData = null;
        let selectedSlot = null;
        let expandedNodes = new Set();
        let collapsedComponents = new Set();
        let nextSlotIdx = 0;
        // Space props state
   
        let editingProps = new Map(); // Track which props are being edited
        let scene = BS.BanterScene.GetInstance();

        // Initialize the inspector
        async function initializeInspector() {
            try {
                // Connect to Unity via the BS library
                if (typeof window.BS !== 'undefined') {
                    console.log('BS library found, attempting to connect to Unity scene...');
                    
                    // Check if we have the necessary BS components
                    if (window.BS.BanterScene && window.BS.GameObject && window.BS.ComponentType) {
                        await connectToUnityScene();
                    } else {
                        console.log('BS library is incomplete, using mock data');
                        console.log('Available BS properties:', Object.keys(window.BS));
                        loadMockSceneData();
                    }
                } else {
                    // Mock data for testing without Unity
                    console.log('BS library not found, using mock data');
                    loadMockSceneData();
                }
            } catch (error) {
                console.error('Failed to initialize inspector:', error);
                showError('Failed to connect to Unity scene');
            }
        }

        // Connect to Unity scene
        async function connectToUnityScene() {
            try {
                // Wait for Unity to be ready
                await new Promise(resolve => {
                    if (scene && scene.unityLoaded) {
                        resolve();
                    } else {
                        scene.addEventListener("unity-loaded", resolve, { once: true });
                    }
                });
                
                console.log('Connected to Unity scene, gathering hierarchy...');
                await gatherSceneHierarchy();
            } catch (error) {
                console.error('Failed to connect to Unity:', error);
                // Fall back to mock data
                loadMockSceneData();
            }
        }
        
        // Gather real scene hierarchy from Unity
        async function gatherSceneHierarchy() {
            const slots = [];
            const slotMap = new Map();
            let slotIdCounter = 0;
                        
            // Helper to convert GameObject to slot format
            async function gameObjectToSlot(gameObject, parentId = null) {
                const slotId = gameObject.id;
                
                // Get transform component for hierarchy info
                const transform = gameObject.GetComponent(BS.ComponentType.Transform);
                
                const slot = {
                    id: slotId,
                    name: gameObject.name || 'Unnamed',
                    parent: parentId,
                    children: [],
                    persistent: true, // We'll need to determine this based on the object
                    active: gameObject.active !== false, // Capture active state
                    components: []
                };
                
                // Extract transform data
                if (transform) {
                    slot.components.push({
                        id: transform.id || null,
                        type: 'Transform',
                        dataType: null,
                        properties: {
                            position: transform.position || { x: 0, y: 0, z: 0 },
                            rotation: transform.rotation || { x: 0, y: 0, z: 0, w: 1 },
                            localScale: transform.localScale || { x: 1, y: 1, z: 1 }
                        }
                    });
                }
                
                // Extract other components
                const componentTypes = [
                    BS.ComponentType.BanterRigidbody,
                    BS.ComponentType.BoxCollider,
                    BS.ComponentType.SphereCollider,
                    BS.ComponentType.CapsuleCollider,
                    BS.ComponentType.MeshCollider,
                    BS.ComponentType.BanterMaterial,
                    BS.ComponentType.BanterText,
                    BS.ComponentType.BanterAudioSource,
                    BS.ComponentType.BanterVideoPlayer,
                    BS.ComponentType.BanterGLTF,
                    BS.ComponentType.Light,
                    BS.ComponentType.Camera
                ];
                
                for (const compType of componentTypes) {
                    try {
                        const comp = gameObject.GetComponent(compType);
                        if (comp) {
                            slot.components.push(await extractComponentData(comp, compType));
                        }
                    } catch (e) {
                        // Component might not exist
                    }
                }
                
                slotMap.set(gameObject.id, slotId);
                slots.push(slot);
                
                // Process children using Traverse method if available
                if (gameObject.Traverse) {
                    const childPromises = [];
                    gameObject.Traverse((child) => {
                        if (child && child.id !== gameObject.id) {
                            if(child.parent == gameObject.id){
                                childPromises.push(gameObjectToSlot(child, slotId));
                            }
                        }
                    });
                    
                    const childSlotIds = await Promise.all(childPromises);
                    slot.children.push(...childSlotIds.filter(id => id));
                }
                
                return slotId;
            }
            
            // Extract component data
            async function extractComponentData(component, type) {
                const componentData = {
                    id: component.id || null, // Capture the unique component ID
                    type: type.toString().replace('BS.ComponentType.', ''),
                    dataType: null,
                    properties: {}
                };
                
                // Extract properties based on component type
                switch (type) {
                    case BS.ComponentType.BanterRigidbody:
                        componentData.properties = {
                            mass: component.mass || 1,
                            drag: component.drag || 0,
                            angularDrag: component.angularDrag || 0.05,
                            useGravity: component.useGravity !== false,
                            isKinematic: component.isKinematic === true
                        };
                        break;
                        
                    case BS.ComponentType.BoxCollider:
                        componentData.properties = {
                            isTrigger: component.isTrigger === true,
                            center: component.center || { x: 0, y: 0, z: 0 },
                            size: component.size || { x: 1, y: 1, z: 1 }
                        };
                        break;
                        
                    case BS.ComponentType.BanterMaterial:
                        componentData.properties = {
                            shaderName: component.shaderName || 'Standard',
                            color: component.color || { r: 1, g: 1, b: 1, a: 1 }
                        };
                        break;
                        
                    case BS.ComponentType.BanterText:
                        componentData.properties = {
                            text: component.text || '',
                            fontSize: component.fontSize || 14,
                            color: component.color || { r: 1, g: 1, b: 1, a: 1 }
                        };
                        break;
                        
                    case BS.ComponentType.Light:
                        componentData.type = 'Light';
                        componentData.properties = {
                            lightType: 'Directional',
                            color: { r: 1, g: 1, b: 1, a: 1 },
                            intensity: 1,
                            shadowType: 'None'
                        };
                        break;
                        
                    case BS.ComponentType.Camera:
                        componentData.type = 'Camera';
                        componentData.properties = {
                            fieldOfView: 60,
                            nearClipPlane: 0.1,
                            farClipPlane: 1000,
                            depth: 0
                        };
                        break;
                }
                
                return componentData;
            }
            
            // Try to find root objects in the scene
            try {
                // First, try to get all GameObjects that might be roots
                const processedObjects = new Set();
                const obj = await scene.Find("Root");
                if (obj) {
                    processedObjects.add(obj.id);
                    await gameObjectToSlot(obj);
                }else{
                    console.log("No root object found");
                }
            } catch (error) {
                console.error('Error gathering scene hierarchy:', error);
                loadMockSceneData();
                return;
            }
            
            // Set the scene data
            sceneData = { slots };
            
            // Expand root nodes by default
            sceneData.slots.forEach(slot => {
                if (!slot.parent && slot.children.length > 0) {
                    expandedNodes.add(slot.id);
                }
            });
            
            renderHierarchy();
        }

        // Load mock scene data for testing
        function loadMockSceneData() {
            sceneData = {
                slots: [
                    {
                        id: 'slot_root',
                        name: 'Root',
                        parent: null,
                        children: ['slot_world', 'slot_ui'],
                        persistent: true,
                        active: true,
                        components: [
                            {
                                type: 'Transform',
                                dataType: null,
                                id: -77708,
                                properties: {
                                    position: { x: 0, y: 0, z: 0 },
                                    rotation: { x: 0, y: 0, z: 0, w: 1 },
                                    localScale: { x: 1, y: 1, z: 1 }
                                }
                            }
                        ]
                    },
                    {
                        id: 'slot_world',
                        name: 'World',
                        parent: 'slot_root',
                        children: ['slot_env', 'slot_player'],
                        persistent: true,
                        active: true,
                        components: [
                            {
                                type: 'Transform',
                                dataType: null,
                                id: -77718,
                                properties: {
                                    position: { x: 0, y: 0, z: 0 },
                                    rotation: { x: 0, y: 0, z: 0, w: 1 },
                                    localScale: { x: 1, y: 1, z: 1 }
                                }
                            }
                        ]
                    },
                    {
                        id: 'slot_ui',
                        name: 'UI',
                        parent: 'slot_root',
                        children: ['slot_hud'],
                        persistent: true,
                        components: [
                            {
                                type: 'Transform',
                                dataType: null,
                                id: -77728,
                                properties: {
                                    position: { x: 0, y: 0, z: 0 },
                                    rotation: { x: 0, y: 0, z: 0, w: 1 },
                                    localScale: { x: 1, y: 1, z: 1 }
                                }
                            },
                            {
                                type: 'Canvas',
                                dataType: null,
                                id: -77738,
                                properties: {
                                    renderMode: 'ScreenSpaceOverlay',
                                    pixelPerfect: true,
                                    sortingOrder: 0
                                }
                            }
                        ]
                    },
                    {
                        id: 'slot_env',
                        name: 'Environment',
                        parent: 'slot_world',
                        children: ['slot_light', 'slot_ground'],
                        persistent: true,
                        components: [
                            {
                                type: 'Transform',
                                dataType: null,
                                id: -77748,
                                properties: {
                                    position: { x: 0, y: 0, z: 0 },
                                    rotation: { x: 0, y: 0, z: 0, w: 1 },
                                    localScale: { x: 1, y: 1, z: 1 }
                                }
                            }
                        ]
                    },
                    {
                        id: 'slot_light',
                        name: 'Directional Light',
                        parent: 'slot_env',
                        children: [],
                        persistent: true,
                        components: [
                            {
                                type: 'Transform',
                                dataType: null,
                                id: -77758,
                                properties: {
                                    position: { x: 0, y: 10, z: 0 },
                                    rotation: { x: 0.4, y: -0.2, z: 0.1, w: 0.9 },
                                    localScale: { x: 1, y: 1, z: 1 }
                                }
                            },
                            {
                                type: 'Light',
                                dataType: null,
                                id: -77768,
                                properties: {
                                    lightType: 'Directional',
                                    color: { r: 1, g: 0.95, b: 0.8, a: 1 },
                                    intensity: 1.2,
                                    shadowType: 'Soft',
                                    shadowStrength: 0.8
                                }
                            }
                        ]
                    },
                    {
                        id: 'slot_ground',
                        name: 'Ground Plane',
                        parent: 'slot_env',
                        children: [],
                        persistent: true,
                        components: [
                            {
                                type: 'Transform',
                                dataType: null,
                                id: -77778,
                                properties: {
                                    position: { x: 0, y: 0, z: 0 },
                                    rotation: { x: 0, y: 0, z: 0, w: 1 },
                                    localScale: { x: 50, y: 1, z: 50 }
                                }
                            },
                            {
                                type: 'MeshRenderer',
                                dataType: null,
                                id: -77788,
                                properties: {
                                    mesh: 'Plane',
                                    material: 'Default-Material',
                                    castShadows: true,
                                    receiveShadows: true
                                }
                            },
                            {
                                type: 'BoxCollider',
                                dataType: null,
                                id: -77798,
                                properties: {
                                    center: { x: 0, y: 0, z: 0 },
                                    size: { x: 1, y: 0.01, z: 1 },
                                    isTrigger: false
                                }
                            }
                        ]
                    },
                    {
                        id: 'slot_player',
                        name: 'Player Controller',
                        parent: 'slot_world',
                        children: ['slot_camera'],
                        persistent: false,
                        components: [
                            {
                                type: 'Transform',
                                dataType: null,
                                id: -77808,
                                properties: {
                                    position: { x: 0, y: 1.6, z: 0 },
                                    rotation: { x: 0, y: 0, z: 0, w: 1 },
                                    localScale: { x: 1, y: 1, z: 1 }
                                }
                            },
                            {
                                type: 'CharacterController',
                                dataType: null,
                                id: -77818,
                                properties: {
                                    height: 1.8,
                                    radius: 0.3,
                                    stepOffset: 0.3,
                                    slopeLimit: 45
                                }
                            },
                            {
                                type: 'PlayerMovement',
                                dataType: null,
                                id: -77828,
                                properties: {
                                    walkSpeed: 5,
                                    runSpeed: 10,
                                    jumpHeight: 1.2,
                                    gravity: -9.81
                                }
                            }
                        ]
                    },
                    {
                        id: 'slot_camera',
                        name: 'Main Camera',
                        parent: 'slot_player',
                        children: [],
                        persistent: false,
                        components: [
                            {
                                type: 'Transform',
                                dataType: null,
                                id: -77838,
                                properties: {
                                    position: { x: 0, y: 0, z: 0 },
                                    rotation: { x: 0, y: 0, z: 0, w: 1 },
                                    localScale: { x: 1, y: 1, z: 1 }
                                }
                            },
                            {
                                type: 'Camera',
                                dataType: null,
                                id: -77848,
                                properties: {
                                    fieldOfView: 60,
                                    nearClipPlane: 0.1,
                                    farClipPlane: 1000,
                                    depth: 0,
                                    clearFlags: 'SolidColor',
                                    backgroundColor: { r: 0.1, g: 0.1, b: 0.1, a: 1 }
                                }
                            }
                        ]
                    },
                    {
                        id: 'slot_hud',
                        name: 'HUD',
                        parent: 'slot_ui',
                        children: [],
                        persistent: true,
                        components: [
                            {
                                type: 'RectTransform',
                                dataType: null,
                                id: -77858,
                                properties: {
                                    anchorMin: { x: 0, y: 0 },
                                    anchorMax: { x: 1, y: 1 },
                                    pivot: { x: 0.5, y: 0.5 },
                                    position: { x: 0, y: 0, z: 0 },
                                    sizeDelta: { x: 0, y: 0 }
                                }
                            }
                        ]
                    }
                ]
            };

            // Expand root nodes by default
            sceneData.slots.forEach(slot => {
                if (!slot.parent && slot.children.length > 0) {
                    expandedNodes.add(slot.id);
                }
            });

            renderHierarchy();
        }

        // Render the hierarchy tree
        function renderHierarchy() {
            const treeContainer = document.getElementById('hierarchyTree');
            const searchTerm = document.getElementById('searchInput').value.toLowerCase();
            
            // Get root slots
            const rootSlots = sceneData.slots.filter(slot => !slot.parent);
            
            treeContainer.innerHTML = '';
            rootSlots.forEach(slot => {
                const node = renderSlotNode(slot, searchTerm, 0);
                if (node) {
                    treeContainer.appendChild(node);
                }
            });
        }

        // Render a single slot node
        function renderSlotNode(slot, searchTerm, level) {
            // Check if this node or any children match the search
            if (searchTerm && !matchesSearch(slot, searchTerm)) {
                return null;
            }

            const container = document.createElement('div');

            // Create node element
            const node = document.createElement('div');
            node.className = 'tree-node';
            if (selectedSlot === slot.id) {
                node.classList.add('selected');
            }
            if (!slot.persistent) {
                node.classList.add('non-persistent');
            }
            if (slot.active === false) {
                node.classList.add('inactive');
            }
            node.style.paddingLeft = `${8 + level * 20}px`;

            const nodeContent = document.createElement('div');
            nodeContent.className = 'node-content';

            // Toggle button
            const toggle = document.createElement('span');
            toggle.className = 'tree-toggle';
            if (slot.children.length > 0) {
                toggle.classList.add('has-children');
                toggle.textContent = expandedNodes.has(slot.id) ? 'â–¼' : 'â–¶';
                toggle.onclick = (e) => {
                    e.stopPropagation();
                    toggleNode(slot.id);
                };
            } else {
                toggle.classList.add('empty');
                toggle.textContent = 'â—';
            }
            nodeContent.appendChild(toggle);

            // Node icon
            const icon = document.createElement('span');
            icon.className = 'node-icon';
            nodeContent.appendChild(icon);

            // Node name
            const name = document.createElement('span');
            name.className = 'node-name';
            name.textContent = slot.name;
            nodeContent.appendChild(name);

            node.appendChild(nodeContent);

            // Click handler
            node.onclick = () => selectSlot(slot.id);

            container.appendChild(node);

            // Render children if expanded
            if (slot.children.length > 0 && expandedNodes.has(slot.id)) {
                slot.children.forEach(childId => {
                    const child = sceneData.slots.find(s => s.id === childId);
                    if (child) {
                        const childNode = renderSlotNode(child, searchTerm, level + 1);
                        if (childNode) {
                            container.appendChild(childNode);
                        }
                    }
                });
            }

            return container;
        }

        // Check if slot matches search
        function matchesSearch(slot, searchTerm) {
            if (slot.name.toLowerCase().includes(searchTerm)) {
                return true;
            }
            
            // Check children
            for (const childId of slot.children) {
                const child = sceneData.slots.find(s => s.id === childId);
                if (child && matchesSearch(child, searchTerm)) {
                    // Expand parent to show matching child
                    expandedNodes.add(slot.id);
                    return true;
                }
            }
            
            return false;
        }

        // Toggle node expansion
        function toggleNode(slotId) {
            if (expandedNodes.has(slotId)) {
                expandedNodes.delete(slotId);
            } else {
                expandedNodes.add(slotId);
            }
            renderHierarchy();
        }

        // Select a slot
        function selectSlot(slotId) {
            selectedSlot = slotId;
            renderHierarchy();
            renderProperties();
        }

        // Render properties panel
        function renderProperties() {
            const propertiesContent = document.getElementById('propertiesContent');
            
            if (!selectedSlot) {
                propertiesContent.innerHTML = `
                    <div class="empty-state">
                        <h3>No Slot Selected</h3>
                        <p>Select a slot from the hierarchy to inspect its components</p>
                    </div>
                `;
                // Hide the Add Component button when no slot is selected
                const addComponentContainer = document.getElementById('addComponentContainer');
                if (addComponentContainer) {
                    addComponentContainer.style.display = 'none';
                }
                return;
            }

            const slot = sceneData.slots.find(s => s.id === selectedSlot);
            if (!slot) return;

            propertiesContent.innerHTML = '';

            // Slot info section
            const infoSection = document.createElement('div');
            infoSection.className = 'component-section';
            
            const header = document.createElement('div');
            header.className = 'component-header';

            const innerDiv = document.createElement('div');
            const slotName = document.createElement('span');
            slotName.className = 'component-name';
            //slotName.textContent = slot.name;
            innerDiv.appendChild(slotName);

            const slotType = document.createElement('span');
            slotType.className = 'component-type';
            slotType.textContent = 'Slot';
            innerDiv.appendChild(slotType);

            header.appendChild(innerDiv);
            infoSection.appendChild(header);
            
            const body = document.createElement('div');
            body.className = 'component-body';
            
            // Active property
            const activeRow = document.createElement('div');
            activeRow.className = 'property-row';
            
            const activeButton = document.createElement('button');
            activeButton.className = 'property-button grabbable';
            activeButton.title = 'Grab value';
            activeButton.textContent = 'â—‰';
            activeRow.appendChild(activeButton);
            
            const activeLabel = document.createElement('span');
            activeLabel.className = 'property-label';
            activeLabel.textContent = 'Active';
            activeRow.appendChild(activeLabel);
            
            const activeValueContainer = document.createElement('div');
            activeValueContainer.className = 'property-value';
            
            const activeCheckbox = document.createElement('input');
            activeCheckbox.type = 'checkbox';
            activeCheckbox.className = 'checkbox-input';
            activeCheckbox.checked = slot.active !== false;
            activeCheckbox.onchange = () => handleSlotActiveChange(slot.id, activeCheckbox.checked);
            activeValueContainer.appendChild(activeCheckbox);
            
            activeRow.appendChild(activeValueContainer);
            body.appendChild(activeRow);
            

            // Name property (rename)
            const nameInput = document.createElement('input');
            nameInput.type = 'text';
            nameInput.className = 'property-input';
            nameInput.value = slot.name;
            nameInput.placeholder = 'Slot name';
            
            // Handle rename on Enter or blur
            const handleRename = async () => {
                const newName = nameInput.value.trim();
                if (newName && newName !== slot.name) {
                    await renameSlot(slot.id, newName);
                } else {
                    nameInput.value = slot.name; // Reset if empty or unchanged
                }
            };
            
            nameInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    nameInput.blur();
                }
            });
            
            nameInput.addEventListener('blur', handleRename);
            slotName.appendChild(nameInput);
         
            
            // Persistent property
            const persistentRow = document.createElement('div');
            persistentRow.className = 'property-row';
            persistentRow.innerHTML = `
                <button class="property-button" title="Clear value">Ã˜</button>
                <span class="property-label">Persistent</span>
                <div class="property-value">
                    <input type="checkbox" class="checkbox-input" ${slot.persistent ? 'checked' : ''} disabled>
                </div>
            `;
            body.appendChild(persistentRow);
            
            infoSection.appendChild(body);
            propertiesContent.appendChild(infoSection);

            // Components
            slot.components.forEach((component) => {
                const componentElement = renderComponent(component);
                propertiesContent.appendChild(componentElement);
            });
            
            // Show the Add Component button when a slot is selected
            const addComponentContainer = document.getElementById('addComponentContainer');
            if (addComponentContainer) {
                addComponentContainer.style.display = 'block';
            }
        }

        // Render a component
        function renderComponent(component) {
            const section = document.createElement('div');
            section.className = 'component-section';
            
            const componentIdentifier = component.id;
            const isCollapsed = collapsedComponents.has(componentIdentifier);

            const header = document.createElement('div');
            header.className = 'component-header grabbable';
            header.innerHTML = `
                <div>
                    <span class="component-name">${component.type}</span>
                    ${component.dataType ? `<span class="component-type">&lt;${component.dataType}&gt;</span>` : ''}
                </div>
                <span class="component-toggle">${isCollapsed ? 'â–¶' : 'â–¼'}</span>
            `;
            header.onclick = () => {
                if (collapsedComponents.has(componentIdentifier)) {
                    collapsedComponents.delete(componentIdentifier);
                } else {
                    collapsedComponents.add(componentIdentifier);
                }
                renderProperties();
            };
            section.appendChild(header);

            if (!isCollapsed) {
                const body = document.createElement('div');
                body.className = 'component-body';

                Object.entries(component.properties).forEach(([key, value], index) => {
                    const propertyRow = renderProperty(key, value, component.type, index);
                    body.appendChild(propertyRow);
                });

                section.appendChild(body);
            }

            return section;
        }

        // Render a property
        function renderProperty(key, value, componentType, propertyIndex) {
            const row = document.createElement('div');
            row.className = 'property-row';
            row.dataset.propertyKey = key;
            row.dataset.componentType = componentType;
            row.dataset.propertyIndex = propertyIndex;

            // Property button
            const button = document.createElement('button');
            button.className = 'property-button grabbable';
            button.title = 'Grab value';
            button.textContent = 'â—‰';
            row.appendChild(button);

            // Property label
            const label = document.createElement('span');
            label.className = 'property-label';
            label.textContent = formatPropertyName(key);
            label.title = key;
            row.appendChild(label);

            // Property value
            const valueContainer = document.createElement('div');
            valueContainer.className = 'property-value';

            // Render based on value type
            if (typeof value === 'boolean') {
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.className = 'checkbox-input';
                checkbox.checked = value;
                checkbox.onchange = () => handlePropertyChange(key, checkbox.checked, componentType, propertyIndex);
                valueContainer.appendChild(checkbox);
            } else if (typeof value === 'number') {
                const input = document.createElement('input');
                input.type = 'number';
                input.className = 'property-input number';
                input.value = value;
                input.step = '0.01';
                input.onchange = () => handlePropertyChange(key, parseFloat(input.value), componentType, propertyIndex);
                valueContainer.appendChild(input);
            } else if (typeof value === 'string') {
                const input = document.createElement('input');
                input.type = 'text';
                input.className = 'property-input';
                input.value = value;
                input.onchange = () => handlePropertyChange(key, input.value, componentType, propertyIndex);
                valueContainer.appendChild(input);
            } else if (value && typeof value === 'object') {
                if (value.x !== undefined && value.y !== undefined && value.z !== undefined && value.w !== undefined) {
                    // Quaternion
                    const group = document.createElement('div');
                    group.className = 'vector-group';
                    ['x', 'y', 'z', 'w'].forEach(axis => {
                        const label = document.createElement('span');
                        label.className = 'vector-label';
                        label.textContent = axis.toUpperCase();
                        group.appendChild(label);
                        
                        const input = document.createElement('input');
                        input.type = 'number';
                        input.className = 'property-input number';
                        input.value = value[axis];
                        input.step = '0.001';
                        input.dataset.axis = axis;
                        input.onchange = () => {
                            const newValue = { ...value };
                            newValue[axis] = parseFloat(input.value);
                            handlePropertyChange(key, newValue, componentType, propertyIndex);
                        };
                        group.appendChild(input);
                    });
                    valueContainer.appendChild(group);
                } else if (value.x !== undefined && value.y !== undefined && value.z !== undefined) {
                    // Vector3
                    const group = document.createElement('div');
                    group.className = 'vector-group';
                    ['x', 'y', 'z'].forEach(axis => {
                        const label = document.createElement('span');
                        label.className = 'vector-label';
                        label.textContent = axis.toUpperCase();
                        group.appendChild(label);
                        
                        const input = document.createElement('input');
                        input.type = 'number';
                        input.className = 'property-input number';
                        input.value = value[axis];
                        input.step = '0.01';
                        input.dataset.axis = axis;
                        input.onchange = () => {
                            const newValue = { ...value };
                            newValue[axis] = parseFloat(input.value);
                            handlePropertyChange(key, newValue, componentType, propertyIndex);
                        };
                        group.appendChild(input);
                    });
                    valueContainer.appendChild(group);
                } else if (value.x !== undefined && value.y !== undefined) {
                    // Vector2
                    const group = document.createElement('div');
                    group.className = 'vector-group';
                    ['x', 'y'].forEach(axis => {
                        const label = document.createElement('span');
                        label.className = 'vector-label';
                        label.textContent = axis.toUpperCase();
                        group.appendChild(label);
                        
                        const input = document.createElement('input');
                        input.type = 'number';
                        input.className = 'property-input number';
                        input.value = value[axis];
                        input.step = '0.01';
                        input.dataset.axis = axis;
                        input.onchange = () => {
                            const newValue = { ...value };
                            newValue[axis] = parseFloat(input.value);
                            handlePropertyChange(key, newValue, componentType, propertyIndex);
                        };
                        group.appendChild(input);
                    });
                    valueContainer.appendChild(group);
                } else if (value.r !== undefined && value.g !== undefined && value.b !== undefined) {
                    // Color
                    const hex = rgbToHex(value.r, value.g, value.b);
                    const colorGroup = document.createElement('div');
                    colorGroup.className = 'color-group';
                    
                    const preview = document.createElement('div');
                    preview.className = 'color-preview';
                    const swatch = document.createElement('div');
                    swatch.className = 'color-swatch';
                    swatch.style.backgroundColor = hex;
                    preview.appendChild(swatch);
                    colorGroup.appendChild(preview);
                    
                    const input = document.createElement('input');
                    input.type = 'text';
                    input.className = 'property-input';
                    input.value = hex;
                    input.onchange = () => {
                        const rgb = hexToRgb(input.value);
                        if (rgb) {
                            const newValue = { r: rgb.r / 255, g: rgb.g / 255, b: rgb.b / 255, a: value.a || 1 };
                            handlePropertyChange(key, newValue, componentType, propertyIndex);
                            swatch.style.backgroundColor = input.value;
                        }
                    };
                    colorGroup.appendChild(input);
                    valueContainer.appendChild(colorGroup);
                }
            }

            row.appendChild(valueContainer);
            return row;
        }

        // Format property name
        function formatPropertyName(name) {
            // Convert camelCase to Title Case
            return name
                .replace(/([A-Z])/g, ' $1')
                .replace(/^./, str => str.toUpperCase())
                .trim();
        }

        // Convert RGB to hex
        function rgbToHex(r, g, b) {
            const toHex = (n) => {
                const hex = Math.round(n * 255).toString(16);
                return hex.length === 1 ? '0' + hex : hex;
            };
            return '#' + toHex(r) + toHex(g) + toHex(b);
        }
        
        // Convert hex to RGB
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        }
        
        // Property change handler with debouncing
        let propertyChangeTimeout = null;
        let pendingChanges = new Map();
        
        async function handlePropertyChange(propertyKey, newValue, componentType, propertyIndex) {
            console.log("handlePropertyChange", propertyKey, newValue, componentType, propertyIndex)
            if (!selectedSlot) return;
            
            const slot = sceneData.slots.find(s => s.id === selectedSlot);
            if (!slot) return;
            
            // Update local data
            const component = slot.components.find(c=>c.type === componentType);
            if (component && component.properties[propertyKey] !== undefined) {
                component.properties[propertyKey] = newValue;
            }
            
            // Create a unique key for this change
            const changeKey = `${selectedSlot}_${componentType}_${propertyIndex}_${propertyKey}`;
            pendingChanges.set(changeKey, {
                slotId: selectedSlot,
                componentId: component.id || null,
                componentType,
                propertyIndex,
                propertyKey,
                newValue,
                slotName: slot.name
            });
            
            // Debounce the actual update
            clearTimeout(propertyChangeTimeout);
            propertyChangeTimeout = setTimeout(() => {
                flushPropertyChanges();
            }, 300);
        }
        
        async function flushPropertyChanges() {
            if (pendingChanges.size === 0) return;
            
            // Group changes by slot for efficient updates
            const changesBySlot = new Map();
            
            pendingChanges.forEach((change, key) => {
                if (!changesBySlot.has(change.slotId)) {
                    changesBySlot.set(change.slotId, []);
                }
                changesBySlot.get(change.slotId).push(change);
            });
            
            // Apply changes to Unity and sync via space props
            for (const [slotId, changes] of changesBySlot) {
                const slot = sceneData.slots.find(s => s.id === slotId);
                if (!slot) continue;
                
                // Try to update Unity components directly
                if (scene && typeof window.BS !== 'undefined') {
                    try {
                        // Find the GameObject
                        const gameObject = scene.objects[slot.id];
                        if (gameObject) {
                            for (const change of changes) {
                                await updateUnityComponent(gameObject, change);
                            }
                        }
                    } catch (error) {
                        console.error('Failed to update Unity component:', error);
                    }
                }
                
                changes.forEach(c => {
                    // Use component ID if available, otherwise fall back to type and index
                    const component = slot.components.find(component=>component.type === c.componentType);
                    const componentId = component?.id;
                    
                    let propKey = `__${slot.id}/${c.componentType}/${c.propertyKey}:${componentId}`;
                    // Store the value with metadata
                    const propValue = {
                        value: c.newValue,
                        componentId: componentId,
                        slotId: slotId,
                        slotName: slot.name,
                        componentType: c.componentType,
                        componentIndex: c.componentIndex,
                        propertyKey: c.propertyKey,
                        timestamp: Date.now()
                    };
                    setSpace(propKey, propValue, false);
                })
            }
            
            pendingChanges.clear();
        }
        
        async function updateUnityComponent(gameObject, change) {
            try {
                // Get the component
                let component = null;
                
                // If we have a component ID, try to find it directly
                if (change.componentId && gameObject.GetComponentById) {
                    component = gameObject.GetComponentById(change.componentId);
                }
                
                // Fallback to type-based lookup
                if (!component) {
                    // Map component type string to BS.ComponentType
                    const componentTypeMap = {
                        'Transform': BS.ComponentType.Transform,
                        'BanterRigidbody': BS.ComponentType.BanterRigidbody,
                        'BoxCollider': BS.ComponentType.BoxCollider,
                        'SphereCollider': BS.ComponentType.SphereCollider,
                        'BanterMaterial': BS.ComponentType.BanterMaterial,
                        'BanterText': BS.ComponentType.BanterText,
                        'Light': BS.ComponentType.Light,
                        'Camera': BS.ComponentType.Camera
                    };
                    
                    const bsComponentType = componentTypeMap[change.componentType];
                    if (bsComponentType) {
                        component = gameObject.GetComponent(bsComponentType);
                    }
                }
                
                if (!component) {
                    console.warn(`Component ${change.componentType} not found on GameObject`);
                    return;
                }
                
                // Update the property
                if (component[change.propertyKey] !== undefined) {
                    // Handle special cases for Unity types
                    if (change.componentType === 'Transform') {
                        if (change.propertyKey === 'position' || change.propertyKey === 'localPosition') {
                            component[change.propertyKey] = new BS.Vector3(change.newValue.x, change.newValue.y, change.newValue.z);
                        } else if (change.propertyKey === 'rotation' || change.propertyKey === 'localRotation') {
                            component[change.propertyKey] = new BS.Quaternion(change.newValue.x, change.newValue.y, change.newValue.z, change.newValue.w);
                        } else if (change.propertyKey === 'localScale') {
                            component[change.propertyKey] = new BS.Vector3(change.newValue.x, change.newValue.y, change.newValue.z);
                        }
                    } else if (change.propertyKey === 'color' && change.newValue.r !== undefined) {
                        component[change.propertyKey] = new BS.Vector4(change.newValue.r, change.newValue.g, change.newValue.b, change.newValue.a || 1);
                    } else {
                        // Direct assignment for simple types
                        component[change.propertyKey] = change.newValue;
                    }
                }
            } catch (error) {
                console.error('Error updating Unity component:', error);
            }
        }

        function getNextSlotIndex(){
            nextSlotIdx += 1
            return nextSlotIdx;
        }

        // Create new child slot
        async function createNewChildSlot(parentSlotId) {
            const parentSlot = sceneData.slots.find(s => s.id === parentSlotId);
            if (!parentSlot) return;
            
            try {
                // Generate a unique name for the new slot
                const slot_idx = getNextSlotIndex()
                const newSlotName = `Empty_${slot_idx}`;
                
                // Create new GameObject using BS library
                let newGameObject = null;
                let parentGameObject = null;
                
                if (scene && typeof window.BS !== 'undefined') {
                    // Find parent GameObject
                    parentGameObject = scene.objects[parentSlot.id];
                    if (!parentGameObject) {
                        console.error('Parent GameObject not found');
                        return;
                    }
                    
                    // Create new GameObject
                    newGameObject = new BS.GameObject(newSlotName);
                    
                    // Add Transform component
                    const transform = await newGameObject.AddComponent(new BS.Transform());
                    transform.position = new BS.Vector3(0, 0, 0);
                    transform.rotation = new BS.Quaternion(0, 0, 0, 1);
                    transform.localScale = new BS.Vector3(1, 1, 1);
                    
                    // Set parent
                    await newGameObject.SetParent(parentGameObject, true);
                    
                    // Ensure it's active
                    await newGameObject.SetActive(true);
                    
                    // Create slot data structure
                    const newSlotId = newGameObject.id;
                    const newSlot = {
                        id: newSlotId,
                        name: newSlotName,
                        parent: parentSlotId,
                        children: [],
                        persistent: false,
                        active: true,
                        components: [
                            {
                                id: transform?.id,
                                type: 'Transform',
                                dataType: null,
                                properties: {
                                    position: { x: 0, y: 0, z: 0 },
                                    rotation: { x: 0, y: 0, z: 0, w: 1 },
                                    localScale: { x: 1, y: 1, z: 1 }
                                }
                            }
                        ]
                    };
                
                    // Add to scene data
                    sceneData.slots.push(newSlot);
                    
                    
                    // Update parent's children array
                    if (!parentSlot.children.includes(newSlotId)) {
                        parentSlot.children.push(newSlotId);
                    }
                    
                    // Expand parent node to show new child
                    expandedNodes.add(parentSlotId);
                    
                    // Select the new slot
                    selectedSlot = newSlotId;
                
                    // Sync through space props
                    oneShotSync('newEmptySlot', {
                        slotId: newSlotId,
                        slotName: newSlotName,
                        parentSlotId: parentSlotId,
                        parentSlotName: parentSlot.name
                    })
    
                    
                    // Re-render UI
                    renderHierarchy();
                    renderProperties();
                    
                    console.log(`Created new slot: ${newSlotName} as child of ${parentSlot.name}`);
                }
                
            } catch (error) {
                console.error('Failed to create new slot:', error);
                alert('Failed to create new slot: ' + error.message);
            }
        }



        // Delete slot and all its children
        async function deleteSlot(slotId) {
            const slot = sceneData.slots.find(s => s.id === slotId);
            if (!slot) return;
            
            try {
                // Find all children to delete (recursive)
                const slotsToDelete = [slotId];
                const findChildren = (parentId) => {
                    sceneData.slots.forEach(s => {
                        if (s.parent === parentId) {
                            slotsToDelete.push(s.id);
                            findChildren(s.id);
                        }
                    });
                };
                findChildren(slotId);
                
                // Delete GameObjects from Unity (starting from leaves)
                if (scene && typeof window.BS !== 'undefined') {
                    // Reverse order to delete children first
                    for (let i = slotsToDelete.length - 1; i >= 0; i--) {
                        const deleteSlot = sceneData.slots.find(s => s.id === slotsToDelete[i]);
                        if (deleteSlot) {
                            try {
                                const gameObject = scene.objects[deleteSlot.id];
                                if (gameObject && gameObject.Destroy) {
                                    await gameObject.Destroy();
                                }
                            } catch (error) {
                                console.error(`Failed to destroy GameObject ${deleteSlot.name}:`, error);
                            }
                        }
                    }
                }
                
                // Remove from local data
                sceneData.slots = sceneData.slots.filter(s => !slotsToDelete.includes(s.id));
                
                // Clear selection if deleted slot was selected
                if (slotsToDelete.includes(selectedSlot)) {
                    selectedSlot = null;
                }
                
                // Sync deletion through space props
                const propValue = {
                    deletedSlots: slotsToDelete.map(id => {
                        const s = sceneData.slots.find(slot => slot.id === id) || { name: 'unknown' };
                        return { id, name: s.name };
                    })
                };
                oneShotSync('deleteSlot', propValue)
                
                // Re-render UI
                renderHierarchy();
                renderProperties();
                
                console.log(`Deleted slot: ${slot.name} and ${slotsToDelete.length - 1} children`);
                
            } catch (error) {
                console.error('Failed to delete slot:', error);
                alert('Failed to delete slot: ' + error.message);
            }
        }

        // Rename slot
        async function renameSlot(slotId, newName) {
            const slot = sceneData.slots.find(s => s.id === slotId);
            if (!slot) return;
            
            // Validate name
            if (!newName || newName === slot.name) return;
            
            // Check if name already exists
            if (sceneData.slots.some(s => s.name === newName && s.id !== slotId)) {
                alert(`A slot named "${newName}" already exists. Please choose a different name.`);
                renderProperties(); // Re-render to reset the input
                return;
            }
            
            const oldName = slot.name;
            
            try {
                // Update Unity GameObject name
                if (scene && typeof window.BS !== 'undefined') {
                    /*
                    const gameObject = await scene.Find(oldName);
                    if (gameObject) {
                        // BS GameObjects might have a name setter or we need to recreate
                        // For now, we'll update our local data and sync through space props
                        // The Unity side should handle the rename when it receives the space prop update
                        gameObject.name = newName;
                    }*/
                }
                
                // Update local data
                slot.name = newName;
                
                // Update children's paths if needed
                const updateChildPaths = (parentId) => {
                    sceneData.slots.forEach(s => {
                        if (s.parent === parentId && s.path) {
                            const pathParts = s.path.split('/');
                            const parentIndex = pathParts.indexOf(oldName);
                            if (parentIndex !== -1) {
                                pathParts[parentIndex] = newName;
                                s.path = pathParts.join('/');
                            }
                        }
                    });
                };
                updateChildPaths(slotId);
                
                // Sync through space props
                oneShotSync('renameSlot', {
                    slotId: slotId,
                    oldName: oldName,
                    newName: newName
                })
                
                // Re-render UI
                renderHierarchy();
                renderProperties();
                
                console.log(`Renamed slot from "${oldName}" to "${newName}"`);
                
            } catch (error) {
                console.error('Failed to rename slot:', error);
                alert('Failed to rename slot: ' + error.message);
                
                // Revert local change
                slot.name = oldName;
                renderProperties();
            }
        }

        // Handle slot active state change
        async function handleSlotActiveChange(slotId, isActive) {
            const slot = sceneData.slots.find(s => s.id === slotId);
            if (!slot) return;
            
            // Update local state
            slot.active = isActive;
            
            // Update Unity GameObject
            if (scene && typeof window.BS !== 'undefined') {
                try {
                    const gameObject = scene.objects[slot.id];
                    if (gameObject && gameObject.SetActive) {
                        await gameObject.SetActive(isActive);
                    }
                } catch (error) {
                    console.error('Failed to set GameObject active state:', error);
                }
            }
            
            // Sync through space props
            const propKey = `__slot/${slot.name}/active`;
            const propValue = {
                slotId: slotId,
                slotName: slot.name,
                value: isActive,
                timestamp: Date.now()
            };
            setSpace(propKey, propValue, false);
        }

        // Show error message
        function showError(message) {
            const treeContainer = document.getElementById('hierarchyTree');
            treeContainer.innerHTML = `<div class="empty-state"><h3>Error</h3><p>${message}</p></div>`;
        }

        // Search handler
        document.getElementById('searchInput').addEventListener('input', (e) => {
            renderHierarchy();
        });

        // Add Child Slot button handler
        document.getElementById('addChildSlotBtn').addEventListener('click', async () => {
            if (!selectedSlot) {
                alert('Please select a parent slot first');
                return;
            }
            await createNewChildSlot(selectedSlot);
        });

        // Delete Slot button handler
        document.getElementById('deleteSlotBtn').addEventListener('click', async () => {
            if (!selectedSlot) {
                alert('Please select a slot to delete');
                return;
            }
            
            const slot = sceneData.slots.find(s => s.id === selectedSlot);
            if (!slot) return;
            
            // Show confirmation dialog
            const hasChildren = sceneData.slots.some(s => s.parent === selectedSlot);
            const message = hasChildren 
                ? `Are you sure you want to delete "${slot.name}" and all its children?`
                : `Are you sure you want to delete "${slot.name}"?`;
                
            if (confirm(message)) {
                await deleteSlot(selectedSlot);
            }
        });

        // Add Component button handler
        document.getElementById('addComponentBtn').addEventListener('click', () => {
            if (!selectedSlot) return;
            showComponentMenu();
        });

        // Close component menu handlers
        document.getElementById('closeComponentMenu').addEventListener('click', () => {
            hideComponentMenu();
        });

        document.getElementById('componentMenuOverlay').addEventListener('click', (e) => {
            if (e.target === e.currentTarget) {
                hideComponentMenu();
            }
        });

        // Component search handler
        document.getElementById('componentSearchInput').addEventListener('input', (e) => {
            const searchTerm = e.target.value.toLowerCase();
            filterComponents(searchTerm);
        });

        // Component item click handlers
        document.querySelectorAll('.component-item').forEach(item => {
            item.addEventListener('click', () => {
                const componentType = item.getAttribute('data-component');
                console.log(`Adding component: ${componentType} to slot ${selectedSlot}`);
                // TODO: Implement actual component addition
                hideComponentMenu();
            });
        });

        // Show component menu
        function showComponentMenu() {
            const overlay = document.getElementById('componentMenuOverlay');
            const searchInput = document.getElementById('componentSearchInput');
            if (overlay) {
                overlay.style.display = 'flex';
                // Reset search and focus
                searchInput.value = '';
                filterComponents('');
                setTimeout(() => searchInput.focus(), 100);
            }
        }

        // Hide component menu
        function hideComponentMenu() {
            const overlay = document.getElementById('componentMenuOverlay');
            if (overlay) {
                overlay.style.display = 'none';
            }
        }

        // Filter components based on search
        function filterComponents(searchTerm) {
            const items = document.querySelectorAll('.component-item');
            const categories = document.querySelectorAll('.component-category');
            
            items.forEach(item => {
                const name = item.querySelector('.component-item-name').textContent.toLowerCase();
                const desc = item.querySelector('.component-item-desc').textContent.toLowerCase();
                const matches = name.includes(searchTerm) || desc.includes(searchTerm);
                item.classList.toggle('hidden', !matches);
            });
            
            // Hide empty categories
            categories.forEach(category => {
                const visibleItems = category.querySelectorAll('.component-item:not(.hidden)');
                category.style.display = visibleItems.length > 0 ? 'block' : 'none';
            });
        }

        // Helper function to check if a value is a Vector3 object
        function isVector3Object(value) {
            return value && 
                   typeof value === 'object' && 
                   typeof value.x === 'number' && 
                   typeof value.y === 'number' && 
                   typeof value.z === 'number' &&
                   Object.keys(value).length === 3;
        }
        
        // Handle Vector3 component changes
        function handleVector3Change(type, key, axis, value) {
            const props = type === 'public' ? scene.spaceState.public : scene.spaceState.protected;
            const currentValue = props[key];
            
            if (!isVector3Object(currentValue)) {
                console.error(`Property ${key} is not a Vector3`);
                return;
            }
            
            // Update the specific axis value
            const newValue = { ...currentValue };
            newValue[axis] = parseFloat(value);
            
            // Update in the props object
            props[key] = newValue;
            
            // If in edit mode, we'll save on explicit save button click
            // Otherwise, for immediate updates, uncomment the line below:
            // saveProp(type, key);
        }

        // Space Props Functions
        async function initializeSpaceProps() {
            if (!scene) {
                console.log('No BS scene available for space props');
                loadMockSpaceProps();
                return;
            }
            
            try {
                // Listen for space state changes
                scene.addEventListener('space-state-changed', handleSpaceStateChange);
                renderSpaceProps();
            } catch (error) {
                console.error('Failed to initialize space props:', error);
                loadMockSpaceProps();
            }
        }
        
        function loadMockSpaceProps() {
            scene.spaceState.public = {
                'gameMode': 'sandbox',
                'maxPlayers': '20',
                'welcomeMessage': 'Welcome to the space!',
                'version': '1.0.0',
                'spawnPoint': { x: 0, y: 1, z: 0 },
                'worldCenter': { x: 10, y: 0, z: -5 },
                // Component property examples that could sync
                'position': { x: 0, y: 0, z: 0 },
                'intensity': 1.2,
                'fieldOfView': 60,
                'lightType': 'Directional'
            };
            
            scene.spaceState.protected = {
                'adminPassword': '***',
                'apiKey': '***',
                'debugMode': 'false',
                'adminSpawn': { x: 0, y: 10, z: 0 },
                // More component properties
                'mass': 1.0,
                'useGravity': true
            };
            
            renderSpaceProps();
        }
        
        function handleSpaceStateChange(event) {
            if (!event.detail || !event.detail.changes) return;
            
            event.detail.changes.forEach(async change => {
                if (!change.property || change.newValue === undefined) return;
                
                // Check if this is an inspector sync property (old format)
                if (change.property.startsWith('inspector_')) {
                    try {
                        const propData = JSON.parse(change.newValue);
                        handleInspectorSync(change.property, propData);
                    } catch (error) {
                        console.error('Failed to parse inspector sync data:', error);
                    }
                }
                // Check if this is a component property sync
                else if (change.property.startsWith('component_')) {
                    try {
                        await handleComponentPropertySync(change.property, change.newValue);
                    } catch (error) {
                        console.error('Failed to sync component property:', error);
                    }
                }
                // Check if this is a slot active state sync
                else if (change.property.startsWith('__slot_active_')) {
                    try {
                        await handleSlotActiveSync(change.property, change.newValue);
                    } catch (error) {
                        console.error('Failed to sync slot active state:', error);
                    }
                }
                // Check if this is a new slot creation
                else if (change.property.startsWith('__slot_created_')) {
                    try {
                        await handleSlotCreatedSync(change.property, change.newValue);
                    } catch (error) {
                        console.error('Failed to sync slot creation:', error);
                    }
                }
            });
            
            // Always re-render space props to show any changes
            renderSpaceProps();
        }
        
        async function handleComponentPropertySync(propKey, propData) {
            // propData can be either the raw value or an object with metadata
            let value, componentId, slotName, componentType, propertyKey, componentIndex;
            
            if (typeof propData === 'object' && propData !== null && 'value' in propData) {
                // New format with metadata
                value = propData.value;
                componentId = propData.componentId;
                slotName = propData.slotName;
                componentType = propData.componentType;
                propertyKey = propData.propertyKey;
                componentIndex = propData.componentIndex || 0;
            } else {
                // Try to parse from the key
                const parts = propKey.replace('component_', '').split('_');
                if (parts.length < 2) return;
                
                // Check if first part is a number (component ID)
                const possibleId = parseInt(parts[0]);
                if (!isNaN(possibleId)) {
                    componentId = possibleId;
                    propertyKey = parts.slice(1).join('_');
                } else {
                    // Old format: component_slotName_componentType_propertyKey
                    slotName = parts[0];
                    componentType = parts[1];
                    propertyKey = parts.slice(2).join('_');
                    componentIndex = 0;
                }
                value = propData;
            }
            
            let component, slot;
            
            // Find component by ID if available
            for (const s of sceneData.slots) {
                const comp = s.components.find(c => c.id === componentId);
                if (comp) {
                    component = comp;
                    slot = s;
                    slotName = s.name;
                    componentType = comp.type;
                    break;
                }
            }
            
            
            if (!component || !slot) return;
            
            // Update local component data
            if (component.properties[propertyKey] !== undefined) {
                component.properties[propertyKey] = value;
                
                // Update Unity if available
                if (scene && typeof window.BS !== 'undefined') {
                    try {
                        const gameObject = scene.objects[slot.id];
                        if (gameObject) {
                            await updateUnityComponent(gameObject, {
                                componentType: componentType,
                                componentIndex: componentIndex,
                                propertyKey: propertyKey,
                                newValue: value
                            });
                        }
                    } catch (error) {
                        console.error('Failed to update Unity component:', error);
                    }
                }
                
                // Re-render if this is the selected slot
                if (selectedSlot === slot.id) {
                    renderProperties();
                }
            }
        }
        
        async function handleSlotActiveSync(propKey, propData) {
            // Extract slot name from property key
            const slotName = propKey.replace('__slot_active_', '');
            
            let slotId, isActive;
            
            if (typeof propData === 'object' && propData !== null) {
                slotId = propData.slotId;
                isActive = propData.active;
            } else {
                // Simple boolean value
                isActive = propData === true || propData === 'true';
            }
            
            // Find the slot
            const slot = slotId ? 
                sceneData.slots.find(s => s.id === slotId) :
                sceneData.slots.find(s => s.name === slotName);
                
            if (!slot) return;
            
            // Update local state
            slot.active = isActive;
            
            // Update Unity GameObject
            if (scene && typeof window.BS !== 'undefined') {
                try {
                    const gameObject = scene.objects[slot.id];
                    if (gameObject && gameObject.SetActive) {
                        await gameObject.SetActive(isActive);
                    }
                } catch (error) {
                    console.error('Failed to set GameObject active state:', error);
                }
            }
            
            // Re-render if this is the selected slot
            if (selectedSlot === slot.id) {
                renderProperties();
            }
            
            // Update hierarchy to show active state changes
            renderHierarchy();
        }

        async function handleSlotCreatedSync(propKey, propData) {
            // Extract slot name from property key
            const slotName = propKey.replace('__slot_created_', '');
            
            // Check if we already have this slot
            const existingSlot = sceneData.slots.find(s => s.name === slotName);
            if (existingSlot) {
                console.log('Slot already exists:', slotName);
                return;
            }
            
            let slotId, parentSlotId, parentSlotName, timestamp;
            
            if (typeof propData === 'object' && propData !== null) {
                slotId = propData.slotId;
                parentSlotId = propData.parentSlotId;
                parentSlotName = propData.parentSlotName;
                timestamp = propData.timestamp;
            } else {
                console.error('Invalid slot creation data');
                return;
            }
            
            // Find parent slot
            const parentSlot = sceneData.slots.find(s => s.id === parentSlotId || s.name === parentSlotName);
            if (!parentSlot) {
                console.error('Parent slot not found');
                return;
            }
            
            try {
                // Create GameObject in Unity if we have access
                let newGameObject = null;
                let transform = null;
                
                if (scene && typeof window.BS !== 'undefined') {
                    // Find parent GameObject
                    const parentGameObject = scene.objects[parentSlot.id];
                    if (parentGameObject) {
                        // Create new GameObject
                        newGameObject = new BS.GameObject(slotName);
                        
                        // Add Transform component
                        transform = await newGameObject.AddComponent(new BS.Transform());
                        transform.position = new BS.Vector3(0, 0, 0);
                        transform.rotation = new BS.Quaternion(0, 0, 0, 1);
                        transform.localScale = new BS.Vector3(1, 1, 1);
                        
                        // Set parent
                        await newGameObject.SetParent(parentGameObject, true);
                        
                        // Ensure it's active
                        await newGameObject.SetActive(true);
                    }
                }
                
                // Create slot data structure
                const newSlot = {
                    id: slotId,
                    name: slotName,
                    parent: parentSlot.id,
                    children: [],
                    persistent: false,
                    active: true,
                    components: [
                        {
                            id: transform?.id || -timestamp,
                            type: 'Transform',
                            dataType: null,
                            properties: {
                                position: { x: 0, y: 0, z: 0 },
                                rotation: { x: 0, y: 0, z: 0, w: 1 },
                                localScale: { x: 1, y: 1, z: 1 }
                            }
                        }
                    ]
                };
                
                // Add to scene data
                sceneData.slots.push(newSlot);
                
                // Update parent's children array
                if (!parentSlot.children.includes(slotId)) {
                    parentSlot.children.push(slotId);
                }
                
                // Re-render hierarchy
                renderHierarchy();
                
                console.log(`Synced new slot creation: ${slotName} as child of ${parentSlot.name}`);
                
            } catch (error) {
                console.error('Failed to sync slot creation:', error);
            }
        }

        async function handleInspectorSync(propKey, propData) {
            // Extract slot ID from property key
            const slotId = propKey.replace('inspector_', '');
            
            // Find the slot in our scene data
            const slot = sceneData.slots.find(s => s.id === slotId);
            if (!slot) {
                console.warn(`Slot ${slotId} not found for sync`);
                return;
            }
            
            // Apply each change
            for (const change of propData.changes) {
                const component = slot.components[change.componentIndex];
                if (component && component.type === change.componentType) {
                    // Update local data
                    component.properties[change.propertyKey] = change.value;
                    
                    // If we have Unity access, update the actual component
                    if (scene && typeof window.BS !== 'undefined') {
                        try {
                            const gameObject = scene.objects[slot.id];
                            if (gameObject) {
                                await updateUnityComponent(gameObject, {
                                    componentType: change.componentType,
                                    componentIndex: change.componentIndex,
                                    propertyKey: change.propertyKey,
                                    newValue: change.value
                                });
                            }
                        } catch (error) {
                            console.error('Failed to sync Unity component:', error);
                        }
                    }
                }
            }
            
            // Re-render properties if this slot is currently selected
            if (selectedSlot === slotId) {
                renderProperties();
            }
        }
        
        function renderSpaceProps() {
            renderPropsList('public', scene.spaceState.public);
            renderPropsList('protected', scene.spaceState.protected);
        }
        
        function renderPropsList(type, props) {
            const listElement = document.getElementById(`${type}PropsList`);
            const countElement = document.getElementById(`${type}PropsCount`);
            const propKeys = Object.keys(props);
            
            countElement.textContent = propKeys.length;
            
            if (propKeys.length === 0) {
                listElement.innerHTML = '<div class="props-empty">No ' + type + ' properties</div>';
                return;
            }
            
            listElement.innerHTML = propKeys.map(key => {
                const value = props[key];
                const isEditing = editingProps.has(`${type}_${key}`);
                const isProtected = type === 'protected';
                
                // Check if this is a Vector3 object
                const isVector3 = isVector3Object(value);
                
                if (isVector3) {
                    // Render Vector3 with individual inputs
                    return `
                        <div class="prop-item" data-prop-type="${type}" data-prop-key="${key}">
                            <div class="prop-key" title="${key}">${key}</div>
                            <div class="prop-value">
                                <div class="vector-group">
                                    <span class="vector-label">X</span>
                                    <input type="number" 
                                           class="property-input number" 
                                           id="${type}_prop_${key}_x"
                                           value="${value.x}" 
                                           step="0.01"
                                           ${!isEditing ? 'disabled' : ''}
                                           onchange="handleVector3Change('${type}', '${key}', 'x', this.value)"
                                           onkeypress="handlePropKeyPress(event, '${type}', '${key}')">
                                    <span class="vector-label">Y</span>
                                    <input type="number" 
                                           class="property-input number" 
                                           id="${type}_prop_${key}_y"
                                           value="${value.y}" 
                                           step="0.01"
                                           ${!isEditing ? 'disabled' : ''}
                                           onchange="handleVector3Change('${type}', '${key}', 'y', this.value)"
                                           onkeypress="handlePropKeyPress(event, '${type}', '${key}')">
                                    <span class="vector-label">Z</span>
                                    <input type="number" 
                                           class="property-input number" 
                                           id="${type}_prop_${key}_z"
                                           value="${value.z}" 
                                           step="0.01"
                                           ${!isEditing ? 'disabled' : ''}
                                           onchange="handleVector3Change('${type}', '${key}', 'z', this.value)"
                                           onkeypress="handlePropKeyPress(event, '${type}', '${key}')">
                                </div>
                                <div class="prop-actions">
                                    ${isEditing ? `
                                        <button class="prop-button save" onclick="saveProp('${type}', '${key}')" title="Save">âœ“</button>
                                        <button class="prop-button" onclick="cancelEditProp('${type}', '${key}')" title="Cancel">âœ•</button>
                                    ` : `
                                        <button class="prop-button" onclick="editProp('${type}', '${key}')" title="Edit">âœŽ</button>
                                    `}
                                    <button class="prop-button delete" onclick="deleteProp('${type}', '${key}')" title="Delete">ðŸ—‘</button>
                                </div>
                            </div>
                        </div>
                    `;
                } else {
                    // Render regular property
                    const displayValue = typeof value === 'object' ? JSON.stringify(value) : value;
                    return `
                        <div class="prop-item" data-prop-type="${type}" data-prop-key="${key}">
                            <div class="prop-key" title="${key}">${key}</div>
                            <div class="prop-value">
                                <input type="text" 
                                       class="prop-input" 
                                       id="${type}_prop_${key}"
                                       value="${displayValue}" 
                                       ${!isEditing ? 'disabled' : ''}
                                       onkeypress="handlePropKeyPress(event, '${type}', '${key}')"
                                       ${isProtected && !isEditing ? 'type="password"' : ''}>
                                <div class="prop-actions">
                                    ${isEditing ? `
                                        <button class="prop-button save" onclick="saveProp('${type}', '${key}')" title="Save">âœ“</button>
                                        <button class="prop-button" onclick="cancelEditProp('${type}', '${key}')" title="Cancel">âœ•</button>
                                    ` : `
                                        <button class="prop-button" onclick="editProp('${type}', '${key}')" title="Edit">âœŽ</button>
                                    `}
                                    <button class="prop-button delete" onclick="deleteProp('${type}', '${key}')" title="Delete">ðŸ—‘</button>
                                </div>
                            </div>
                        </div>
                    `;
                }
            }).join('');
        }
        
        function editProp(type, key) {
            const propId = `${type}_${key}`;
            editingProps.set(propId, true);
            const props = type === 'public' ? scene.spaceState.public : scene.spaceState.protected;
            renderPropsList(type, props);
            
            // Focus the appropriate input
            const value = props[key];
            if (isVector3Object(value)) {
                // Focus the X input for Vector3
                const xInput = document.getElementById(`${type}_prop_${key}_x`);
                if (xInput) {
                    xInput.focus();
                    xInput.select();
                }
            } else {
                // Focus regular input
                const input = document.getElementById(`${type}_prop_${key}`);
                if (input) {
                    input.focus();
                    input.select();
                }
            }
        }
        
        function cancelEditProp(type, key) {
            const propId = `${type}_${key}`;
            editingProps.delete(propId);
            renderPropsList(type, type === 'public' ? scene.spaceState.public : scene.spaceState.protected);
        }
        
        async function saveProp(type, key) {
            const props = type === 'public' ? scene.spaceState.public : scene.spaceState.protected;
            const currentValue = props[key];
            let newValue;
            
            // Check if this is a Vector3
            if (isVector3Object(currentValue)) {
                // Get values from individual inputs
                const xInput = document.getElementById(`${type}_prop_${key}_x`);
                const yInput = document.getElementById(`${type}_prop_${key}_y`);
                const zInput = document.getElementById(`${type}_prop_${key}_z`);
                
                if (!xInput || !yInput || !zInput) return;
                
                newValue = {
                    x: parseFloat(xInput.value),
                    y: parseFloat(yInput.value),
                    z: parseFloat(zInput.value)
                };
            } else {
                // Regular property
                const input = document.getElementById(`${type}_prop_${key}`);
                if (!input) return;
                
                // Try to parse as JSON if it looks like an object
                newValue = input.value;
                if (newValue.startsWith('{') || newValue.startsWith('[')) {
                    try {
                        newValue = JSON.parse(newValue);
                    } catch (e) {
                        // Keep as string if JSON parse fails
                    }
                }
            }
            
            try {
                if (scene) {
                    if (type === 'public') {
                        setSpace(key, newValue, false)
                    } else {
                        setSpace(key, newValue, true)
                    }
                }
                
                editingProps.delete(`${type}_${key}`);
                renderPropsList(type, props);
            } catch (error) {
                console.error('Failed to save property:', error);
                alert('Failed to save property: ' + error.message);
            }
        }
        
        async function deleteProp(type, key) {
            if (!confirm(`Delete ${type} property "${key}"?`)) return;
            
            
            try {
                if (type === 'public') {                    
                    setSpace(key, null, false)
                    delete scene.spaceState.public[key];
                } else {
                    setSpace(key, null, true)
                    delete scene.spaceState.public[key];
                }
                
                renderSpaceProps();
            } catch (error) {
                console.error('Failed to delete property:', error);
                alert('Failed to delete property: ' + error.message);
            }
        }
        
        function addPublicProp() {
            const keyInput = document.getElementById('addPublicKey');
            const valueInput = document.getElementById('addPublicValue');
            
            if (!keyInput.value.trim()) {
                alert('Please enter a property key');
                return;
            }
            
            const key = keyInput.value.trim();
            let value = valueInput.value.trim();
            
            if (scene.spaceState.public.hasOwnProperty(key)) {
                alert('Property already exists');
                return;
            }
            
            // Try to parse the value
            if (value.startsWith('{') || value.startsWith('[')) {
                try {
                    value = JSON.parse(value);
                } catch (e) {
                    // Keep as string if JSON parse fails
                }
            }
            
            try {
                setSpace(key, value, false)
                
                keyInput.value = '';
                valueInput.value = '';
                renderSpaceProps();
            } catch (error) {
                console.error('Failed to add property:', error);
                alert('Failed to add property: ' + error.message);
            }
        }
        
        function addProtectedProp() {
            const keyInput = document.getElementById('addProtectedKey');
            const valueInput = document.getElementById('addProtectedValue');
            
            if (!keyInput.value.trim()) {
                alert('Please enter a property key');
                return;
            }
            
            const key = keyInput.value.trim();
            let value = valueInput.value.trim();
            
            if (scene.spaceState.protected.hasOwnProperty(key)) {
                alert('Property already exists');
                return;
            }
            
            // Try to parse the value
            if (value.startsWith('{') || value.startsWith('[')) {
                try {
                    value = JSON.parse(value);
                } catch (e) {
                    // Keep as string if JSON parse fails
                }
            }
            
            try {
                setSpace(key, value, true)
                
                keyInput.value = '';
                valueInput.value = '';
                renderSpaceProps();
            } catch (error) {
                console.error('Failed to add property:', error);
                alert('Failed to add property: ' + error.message);
            }
        }
        
        function handlePropKeyPress(event, type, key) {
            if (event.key === 'Enter') {
                saveProp(type, key);
            } else if (event.key === 'Escape') {
                cancelEditProp(type, key);
            }
        }
        
        // Add enter key support for add property inputs
        document.addEventListener('DOMContentLoaded', () => {
            ['addPublicKey', 'addPublicValue'].forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    element.addEventListener('keypress', (e) => {
                        if (e.key === 'Enter') addPublicProp();
                    });
                }
            });
            
            ['addProtectedKey', 'addProtectedValue'].forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    element.addEventListener('keypress', (e) => {
                        if (e.key === 'Enter') addProtectedProp();
                    });
                }
            });
        });

        // Initialize on load
        window.addEventListener('load', () => {
            initializeInspector();
            initializeSpaceProps();
        });

        // Expose API for Unity integration
        window.UnityInspector = {
            updateSceneData: (data) => {
                sceneData = data;
                renderHierarchy();
                if (selectedSlot && !sceneData.slots.find(s => s.id === selectedSlot)) {
                    selectedSlot = null;
                    renderProperties();
                }
            },
            selectSlot: (id) => {
                selectSlot(id);
            }
        };

        window.oneShotSync = async (task, data) => {
            // TODO: Implement one shot syncing
        }

        window.setSpace = async (prop, value, isProtected) => {
            if(!scene) return;
            console.log("SET SPACE", prop, value, isProtected)
            // Check if this prop corresponds to a component property
            // Look for existing component_ prefixed props that might need updating
            if(prop.startsWith('__slot')){
                if(value.value !== undefined){
                    value = value.value
                }else{
                    await checkAndSyncSlotProperty(prop, value, isProtected);
                }
            }else if (prop.startsWith('__') || prop.startsWith('inspector_')) {
                if(value.value !== undefined){ // this is being updated via inspector, so components are already updated
                    value = value.value
                }else{ // this is being updated via space props, so we need to sync the components
                    await checkAndSyncComponentProperty(prop, value, isProtected);
                }
            }

            

            
            // Update the space prop
            if(isProtected){
                scene.SetProtectedSpaceProps({[prop]: value});
                scene.spaceState.protected[prop] = value;
            }else{
                scene.SetPublicSpaceProps({[prop]: value});
                scene.spaceState.public[prop] = value;
            }
            
            
            
            renderSpaceProps();
        }

        function getComponentById(componentId){
            console.log("fetching component by id", componentId)
            for(const slot of sceneData.slots){
                for(const component of slot.components){
                    if(component.id == componentId){
                        return {'component': component, 'slot': slot};
                    }
                }
            }
            console.log("component not found")
            return null;
        }

        async function checkAndSyncSlotProperty(propKey, value, isProtected){

            console.log("CHECK AND SYNC SLOT PROPERTY", propKey, value, isProtected)
            let items = propKey.split('/')
            console.log("items", items)
            if(items[items.length - 1] === 'active'){
                let activeVal = value === 'true'
                let slot = sceneData.slots.find(s=>s.name === items[1])
                if(slot){
                    slot.active = activeVal
                    let gameObject = scene.objects[slot.id]
                    if(gameObject){
                        gameObject.SetActive(activeVal)
                    }
                }
            }
            renderProperties();
        }
        
        async function checkAndSyncComponentProperty(propKey, value, isProtected) {
            console.log("CHECK AND SYNC COMPONENT PROPERTY", propKey, value, isProtected)
            let items = propKey.split(':')
            let id = items[1]
            let path = items[0].split('/')
            let property = path[path.length - 1]
            let output = getComponentById(id)
            if(!output) return;
            let {component, slot} = output;
            console.log("component found", component, slot)
            if(component){
                component.properties[property] = value;
            }

            if (scene && typeof window.BS !== 'undefined') {
                try {
                    const gameObject = scene.objects[slot.id];
                    if (gameObject) {
                        await updateUnityComponent(gameObject, {
                            componentType: component.type,
                            componentIndex: id,
                            propertyKey: property,
                            newValue: value
                        });
                    }
                } catch (error) {
                    console.error('Failed to update Unity component:', error);
                }
            }

            // Re-render if this is the selected slot
            if (selectedSlot === slot.id) {
                renderProperties();
            }
        }
    </script>

    <!-- Component Menu Overlay -->
    <div class="component-menu-overlay" id="componentMenuOverlay" style="display: none;">
        <div class="component-menu">
            <div class="component-menu-header">
                <h2>Add Component</h2>
                <button class="close-button" id="closeComponentMenu">Ã—</button>
            </div>
            
            <div class="component-menu-search">
                <input type="text" class="component-search-input" id="componentSearchInput" placeholder="Search components...">
            </div>
            
            <div class="component-menu-content">
                <!-- Physics Category -->
                <div class="component-category">
                    <div class="category-header">
                        <span class="category-icon">âš›</span>
                        <span class="category-name">Physics</span>
                    </div>
                    <div class="category-items">
                        <div class="component-item" data-component="BanterRigidbody">
                            <span class="component-item-name">Rigidbody</span>
                            <span class="component-item-desc">Enables physics simulation</span>
                        </div>
                        <div class="component-item" data-component="BoxCollider">
                            <span class="component-item-name">Box Collider</span>
                            <span class="component-item-desc">Box-shaped collision detection</span>
                        </div>
                        <div class="component-item" data-component="SphereCollider">
                            <span class="component-item-name">Sphere Collider</span>
                            <span class="component-item-desc">Sphere-shaped collision detection</span>
                        </div>
                        <div class="component-item" data-component="CapsuleCollider">
                            <span class="component-item-name">Capsule Collider</span>
                            <span class="component-item-desc">Capsule-shaped collision detection</span>
                        </div>
                        <div class="component-item" data-component="MeshCollider">
                            <span class="component-item-name">Mesh Collider</span>
                            <span class="component-item-desc">Mesh-based collision detection</span>
                        </div>
                    </div>
                </div>
                
                <!-- Rendering Category -->
                <div class="component-category">
                    <div class="category-header">
                        <span class="category-icon">ðŸŽ¨</span>
                        <span class="category-name">Rendering</span>
                    </div>
                    <div class="category-items">
                        <div class="component-item" data-component="BanterGeometry">
                            <span class="component-item-name">Geometry</span>
                            <span class="component-item-desc">3D procedural shapes</span>
                        </div>
                        <div class="component-item" data-component="BanterMaterial">
                            <span class="component-item-name">Material</span>
                            <span class="component-item-desc">Surface appearance</span>
                        </div>
                        <div class="component-item" data-component="BanterText">
                            <span class="component-item-name">Text</span>
                            <span class="component-item-desc">3D text display</span>
                        </div>
                        <div class="component-item" data-component="BanterBillboard">
                            <span class="component-item-name">Billboard</span>
                            <span class="component-item-desc">Always faces camera</span>
                        </div>
                        <div class="component-item" data-component="BanterMirror">
                            <span class="component-item-name">Mirror</span>
                            <span class="component-item-desc">Reflective surface</span>
                        </div>
                    </div>
                </div>
                
                <!-- Media Category -->
                <div class="component-category">
                    <div class="category-header">
                        <span class="category-icon">ðŸŽ¬</span>
                        <span class="category-name">Media</span>
                    </div>
                    <div class="category-items">
                        <div class="component-item" data-component="BanterAudioSource">
                            <span class="component-item-name">Audio Source</span>
                            <span class="component-item-desc">Play sounds and music</span>
                        </div>
                        <div class="component-item" data-component="BanterVideoPlayer">
                            <span class="component-item-name">Video Player</span>
                            <span class="component-item-desc">Play video content</span>
                        </div>
                        <div class="component-item" data-component="BanterBrowser">
                            <span class="component-item-name">Web Browser</span>
                            <span class="component-item-desc">Embed web content</span>
                        </div>
                    </div>
                </div>
                
                <!-- Interaction Category -->
                <div class="component-category">
                    <div class="category-header">
                        <span class="category-icon">ðŸ¤š</span>
                        <span class="category-name">Interaction</span>
                    </div>
                    <div class="category-items">
                        <div class="component-item" data-component="BanterGrabHandle">
                            <span class="component-item-name">Grab Handle</span>
                            <span class="component-item-desc">Make object grabbable</span>
                        </div>
                        <div class="component-item" data-component="BanterHeldEvents">
                            <span class="component-item-name">Held Events</span>
                            <span class="component-item-desc">Input while holding</span>
                        </div>
                        <div class="component-item" data-component="BanterAttachedObject">
                            <span class="component-item-name">Attached Object</span>
                            <span class="component-item-desc">Attach to users</span>
                        </div>
                        <div class="component-item" data-component="BanterSyncedObject">
                            <span class="component-item-name">Synced Object</span>
                            <span class="component-item-desc">Network synchronization</span>
                        </div>
                    </div>
                </div>
                
                <!-- Loading Category -->
                <div class="component-category">
                    <div class="category-header">
                        <span class="category-icon">ðŸ“¦</span>
                        <span class="category-name">Loading</span>
                    </div>
                    <div class="category-items">
                        <div class="component-item" data-component="BanterGLTF">
                            <span class="component-item-name">GLTF Model</span>
                            <span class="component-item-desc">Load 3D models</span>
                        </div>
                        <div class="component-item" data-component="BanterAssetBundle">
                            <span class="component-item-name">Asset Bundle</span>
                            <span class="component-item-desc">Unity asset bundles</span>
                        </div>
                        <div class="component-item" data-component="BanterPortal">
                            <span class="component-item-name">Portal</span>
                            <span class="component-item-desc">Portal to other spaces</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</body>
</html>