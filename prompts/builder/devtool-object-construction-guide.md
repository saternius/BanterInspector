# Chrome DevTools Agent Object Construction Guide

A strategic guide for agents using Chrome DevTools MCP to construct objects in the Banter VR platform.

**Last Updated**: 2025-10-13
**Purpose**: Ideological framework and practical patterns for object construction via JavaScript injection

---

## Table of Contents

1. [Philosophy & Strategy](#philosophy--strategy)
2. [Paradigm Selection Guide](#paradigm-selection-guide)
3. [Critical: Scripting vs UI Construction](#critical-scripting-vs-ui-construction)
4. [DECLARATIVE: Inventory-Based Construction](#declarative-inventory-based-construction)
5. [IMPERATIVE: Change Command Construction](#imperative-change-command-construction)
6. [Component Composition Patterns](#component-composition-patterns)
7. [Code Injection Templates](#code-injection-templates)
8. [Validation & Testing](#validation--testing)
9. [Common Pitfalls & Solutions](#common-pitfalls--solutions)
10. [Quick Reference](#quick-reference)

---

## Philosophy & Strategy

### The Two Programming Paradigms

When constructing objects via scripting, you have two fundamentally different approaches:

#### 1. DECLARATIVE APPROACH (What You Want)
**Method**: Create complete data structure ‚Üí Save to inventory ‚Üí Load to scene

```javascript
// Define WHAT you want as a complete specification
const objectSpec = {
  name: "MyObject",
  transform: { position: {x:0, y:1, z:0} },
  components: [/* all components */]
};
// Save it, then load it
```

**Philosophy**: "Describe the desired end state"
- You define the complete object structure upfront
- Single atomic operation when loading
- Object is either fully created or not at all
- Natural for templates and reusable prefabs

#### 2. IMPERATIVE APPROACH (How to Build It)
**Method**: Use global command functions to modify scene step-by-step

```javascript
// Define HOW to build it through sequential operations
// Note: Use global functions, NOT ChangeTypes.classes
let entity = await AddEntity("Scene", "MyObject", {context: 'script'});
await AddComponent(entity.id, "BanterBox", {context: 'script'});
let material = await AddComponent(entity.id, "BanterMaterial", {context: 'script'});
await SetComponentProp(material.id, "color", {r:1, g:0, b:0}, {context: 'script'})
await SetEntityProp(entity.id, "localPosition", {x:0, y:1, z:0}, {context: 'script'});
```

**Philosophy**: "Give instructions to construct"
- You issue commands that modify the scene directly
- Each operation happens immediately
- Can build conditionally based on results
- Natural for modifications and dynamic construction

### Core Principles for Scripted Construction

1. **Choose Your Paradigm First**
   - Declarative for known structures and templates
   - Imperative for dynamic building and modifications
   - Don't mix paradigms within a single construction task

2. **Explicit Declaration - No Magic**
   - Always pass `{context: 'script'}` to identify agent operations
   - When scripting, YOU must add EVERY component explicitly
   - No auto-imports or bundling happens in scripted construction
   - Component dependencies must be manually satisfied
   - This applies to BOTH paradigms

3. **Scripting vs UI Construction - Critical Difference**
   - **UI Construction**: Auto-imports dependencies with `{source: "ui"}`
   - **Scripted Construction**: NO auto-imports, all components must be explicit
   - Example: BanterGeometry needs BanterMaterial? You must add BOTH
   - Example: Need collision events? Must explicitly add BanterColliderEvents

4. **Transform is Special**
   - Transform is NOT a component anymore in the new format
   - Transform data lives at the entity level
   - Auto-generated by the system when entity is created

5. **Always Verify Construction**
   - Check entity exists: `SM.getEntityById(path)`
   - Check component added: `SM.getEntityComponentById(componentId)`
   - Verify all required components are present
   - Validate via snapshot: `mcp__chrome-devtools__take_snapshot()`

---

## Paradigm Selection Guide

### When to Use Each Approach

| Use Case | DECLARATIVE (Inventory) | IMPERATIVE (Change Commands) |
|----------|-------------------------|------------------------------|
| **Creating known structures** | ‚úÖ Best choice | ‚ùå Verbose |
| **Building templates/prefabs** | ‚úÖ Best choice | ‚ùå Not reusable |
| **Modifying existing objects** | ‚ùå Can't modify | ‚úÖ Best choice |
| **Conditional construction** | ‚ùå All or nothing | ‚úÖ Best choice |
| **Batch creation with variations** | ‚ùå Requires multiple saves | ‚úÖ Best choice |
| **Runtime generation** | ‚ùå Overhead of save/load | ‚úÖ Best choice |
| **Collaborative/shared objects** | ‚úÖ Best choice | ‚ùå No persistence |
| **Version control needed** | ‚úÖ Has history | ‚ùå No history |
| **Atomic operations required** | ‚úÖ All or nothing | ‚ùå Partial states possible |
| **Learning from examples** | ‚úÖ Complete structure visible | ‚ùå Must trace operations |

### Decision Matrix

```
START: What are you building?
    ‚îÇ
    ‚îú‚îÄ A complete object with known structure?
    ‚îÇ   ‚îî‚îÄ DECLARATIVE ‚Üí Define data, save to inventory, load
    ‚îÇ
    ‚îú‚îÄ Modifying something that already exists?
    ‚îÇ   ‚îî‚îÄ IMPERATIVE ‚Üí Use Change commands directly
    ‚îÇ
    ‚îú‚îÄ Building dynamically based on conditions?
    ‚îÇ   ‚îî‚îÄ IMPERATIVE ‚Üí Use Change commands with logic
    ‚îÇ
    ‚îú‚îÄ Creating a reusable template/prefab?
    ‚îÇ   ‚îî‚îÄ DECLARATIVE ‚Üí Save to inventory for reuse
    ‚îÇ
    ‚îî‚îÄ Experimenting/prototyping?
        ‚îú‚îÄ Will you reuse it? ‚Üí DECLARATIVE
        ‚îî‚îÄ Just testing? ‚Üí IMPERATIVE
```

### The Definitive Rule

**Use DECLARATIVE when you know WHAT you want.**
**Use IMPERATIVE when you need to control HOW it's built.**

---

## Critical: Scripting vs UI Construction

### The Fundamental Difference

When constructing objects in Banter, there are two contexts:

1. **UI Context** (`{source: "ui"}`)
   - Used when humans click buttons in the Inspector UI
   - Auto-imports dependent components for convenience
   - Example: Adding BanterGeometry auto-adds BanterMaterial
   - Example: Adding BoxCollider might auto-add BanterColliderEvents
   - Designed for user-friendly manual building

2. **Scripting Context** (default)
   - Used when injecting JavaScript via Chrome DevTools
   - NO auto-imports - you get exactly what you specify
   - Full control and full responsibility
   - Must explicitly add ALL components you need

### Why This Matters for Agents

As a Chrome DevTools agent, you are ALWAYS in the **scripting context**. This means:

```javascript
// ‚ùå WRONG ASSUMPTION: "BanterBox will auto-include BanterMaterial"
await AddComponent(entityId, "BanterBox");
// Result: Box with NO material (invisible/default)

// ‚úÖ CORRECT: Explicitly add both components
await AddComponent(entityId, "BanterBox");
await AddComponent(entityId, "BanterMaterial");
// Result: Box with material as intended
```

### Component Dependency Reference

When scripting, you must manually satisfy these common dependencies:

| Primary Component | Required Dependencies | Optional Enhancements |
|------------------|----------------------|----------------------|
| **BanterGeometry** | BanterMaterial | - |
| **BanterBox/Sphere/etc** | BanterMaterial | - |
| **BanterGrabbable** | Collider (Box/Sphere/etc), BanterRigidbody | BanterHeldEvents |
| **BanterRigidbody** | Collider (Box/Sphere/etc) | BanterPhysicMaterial |
| **Colliders** | - | BanterColliderEvents (for triggers) |
| **BanterText** | BanterMaterial | - |
| **Joints** | BanterRigidbody on both entities | - |

### Example: Building a Grabbable Cube

**UI Context (what a human would experience):**
1. Add BanterBox ‚Üí Material auto-added
2. Add BanterGrabbable ‚Üí Collider and Rigidbody auto-added
3. Done!

**Scripting Context (what you must do):**
```javascript
// Must explicitly add ALL components
const components = [
  { type: "BanterBox" },           // The mesh
  { type: "BanterMaterial" },      // Must add explicitly!
  { type: "BoxCollider" },         // Must add explicitly!
  { type: "BanterRigidbody" },     // Must add explicitly!
  { type: "BanterGrabbable" }      // Finally, the grab behavior
];
```

### The Scripting Mindset

**"Explicit is better than implicit"** - When scripting:
- Assume nothing is automatic
- Add every component you need
- Verify each component was added
- Check dependencies are satisfied

This gives you complete control but requires complete specification.

---

## DECLARATIVE: Inventory-Based Construction

### Philosophy: "Define WHAT You Want"
This paradigm is about describing the complete desired state as a data structure, then materializing it atomically.

### When to Use
- **Known structures**: You know exactly what the final object should be
- **Templates/Prefabs**: Creating reusable object definitions
- **Complex objects**: Multi-component structures that should be created atomically
- **Persistence needed**: Objects that must survive across sessions
- **Version control**: Need history tracking and rollback capabilities
- **Shared objects**: Multiple agents/users need the same object definition

### Step-by-Step Process

#### 1. Construct the Entity Data Structure

```javascript
// Basic entity structure (NEW FORMAT - no Transform component)
const entityData = {
  name: "MyCustomObject",
  active: true,
  layer: 0,  // Default layer
  persistent: true,

  // Transform at entity level (NOT as component)
  transform: {
    localPosition: { x: 0, y: 1, z: 0 },
    localRotation: { x: 0, y: 0, z: 0, w: 1 },
    localScale: { x: 1, y: 1, z: 1 }
  },

  // Components array
  components: [
    // Add components here (see patterns below)
  ]
};
```

#### 2. Add Components to the Entity

```javascript
// Example: Box with material
entityData.components = [
  {
    type: "BanterBox",
    properties: {
      // Box is a simplified geometry type
    }
  },
  {
    type: "BanterMaterial",
    properties: {
      color: { r: 1, g: 0.5, b: 0.2, a: 1 },
      shaderName: "Unlit/Diffuse",
      generateMipMaps: true,
      side: 0
    }
  }
];

// Example: GLTF model with grabbable behavior
entityData.components = [
  {
    type: "BanterGLTF",
    properties: {
      url: "https://your-cdn.com/model.glb",
      addColliders: true,
      nonConvexColliders: false,
      legacyRotate: false
    }
  },
  {
    type: "BanterGrabbable"
  }
];
```

#### 3. Create Inventory Item Structure

```javascript
const inventoryItem = {
  author: SM.scene?.localUser?.name || 'Agent',
  name: "MyCustomObject",
  created: Date.now(),
  last_used: Date.now(),
  itemType: "entity",
  icon: "üì¶",
  description: "Custom object created by agent",
  data: entityData,
  folder: null  // or specify folder name
};
```

#### 4. Save to Inventory

```javascript
// Method A: Using SetItem global function
await mcp__chrome-devtools__evaluate_script({
  function: `async () => {
    const inventoryItem = ${JSON.stringify(inventoryItem)};
    const result = await SetItem(inventoryItem, { context: 'script' });
    return {
      success: result !== null,
      itemName: inventoryItem.name
    };
  }`
});

// Method B: Using SaveEntityItem global function (if entity exists in scene)
await mcp__chrome-devtools__evaluate_script({
  function: `async () => {
    const entityId = "Scene/TempEntity";  // Must exist
    const itemName = "MyCustomObject";
    const folder = null;  // root folder

    // Use global function, not Change class
    const result = await SaveEntityItem(
      entityId, itemName, folder, { context: 'script' }
    );
    return { success: result !== null, itemName };
  }`
});
```

#### 5. Load from Inventory to Scene

```javascript
await mcp__chrome-devtools__evaluate_script({
  function: `async () => {
    const itemName = "MyCustomObject";
    const parentId = "Scene";  // or specific parent path

    // Use global function, not Change class
    const entity = await LoadItem(
      itemName, parentId, null, { context: 'script' }
    );
    return {
      success: entity !== null,
      entityId: entity?.id
    };
  }`
});
```

---

## IMPERATIVE: Change Command Construction

### Philosophy: "Define HOW to Build It"
This paradigm is about issuing sequential commands that progressively build or modify objects in the scene.

### When to Use
- **Modifying existing objects**: Changing properties or adding components to existing entities
- **Dynamic construction**: Building based on runtime conditions or user input
- **Iterative building**: Creating objects step-by-step with validation between steps
- **Batch operations with variations**: Creating multiple similar objects with differences
- **Quick experiments**: Rapid prototyping without saving to inventory
- **Conditional logic**: When construction depends on intermediate results

### Step-by-Step Process

#### 1. Create Entity

```javascript
await mcp__chrome-devtools__evaluate_script({
  function: `async () => {
    const parentId = "Scene";
    const entityName = "TestCube_1234";

    // Use global function, not Change class
    const entity = await AddEntity(
      parentId, entityName, { context: 'script' }
    );

    return {
      success: entity !== null,
      entityId: entity?.id
    };
  }`
});
```

#### 2. Add Components

```javascript
// Add a box mesh
await mcp__chrome-devtools__evaluate_script({
  function: `async () => {
    const entityId = "Scene/TestCube_1234";  // Use actual entity ID

    // Use global function
    const component = await AddComponent(
      entityId, "BanterBox", { context: 'script' }
    );

    return {
      success: component !== null,
      componentId: component?.id
    };
  }`
});

// Add material (REQUIRED for visibility - not auto-included in script context!)
await mcp__chrome-devtools__evaluate_script({
  function: `async () => {
    const entityId = "Scene/TestCube_1234";

    // Use global function with initial properties
    const component = await AddComponent(
      entityId,
      "BanterMaterial",
      {
        componentProperties:{
          color: { r: 0.2, g: 0.5, b: 1, a: 1 } 
        },
        context: 'script'
      }
    );

    return {
      success: component !== null,
      componentId: component?.id
    };
  }`
});
```

#### 3. Modify Properties

```javascript
// Set entity position
await mcp__chrome-devtools__evaluate_script({
  function: `async () => {
    const entityId = "Scene/TestCube_1234";
    const newPosition = { x: 2, y: 1, z: -3 };

    // Use global function
    await SetEntityProp(
      entityId, "localPosition", newPosition, { context: 'script' }
    );

    return { success: true };
  }`
});

// Set component property
await mcp__chrome-devtools__evaluate_script({
  function: `async () => {
    const componentId = "BanterMaterial_12345";  // Actual component ID
    const newColor = { r: 1, g: 0, b: 0, a: 1 };

    // Use global function
    await SetComponentProp(
      componentId, "color", newColor, { context: 'script' }
    );

    return { success: true };
  }`
});
```

---

## Paradigm Comparison: Same Object, Two Approaches

Let's build the same grabbable cube using both paradigms to illustrate the fundamental difference:

### The Object: A Red Grabbable Cube at Position (2, 1, 0)

#### DECLARATIVE Approach

```javascript
// 1. Define the complete structure
const grabbableCube = {
  name: "RedGrabbableCube",
  author: "Agent",
  created: Date.now(),
  last_used: Date.now(),
  itemType: "entity",
  data: {
    active: true,
    layer: 0,
    transform: {
      localPosition: { x: 2, y: 1, z: 0 },
      localRotation: { x: 0, y: 0, z: 0, w: 1 },
      localScale: { x: 1, y: 1, z: 1 }
    },
    components: [
      { type: "BanterBox" },
      {
        type: "BanterMaterial",
        properties: { color: { r: 1, g: 0, b: 0, a: 1 } }
      },
      { type: "BoxCollider" },
      {
        type: "BanterRigidbody",
        properties: { mass: 1, useGravity: true }
      },
      {
        type: "BanterGrabbable"
      }
    ]
  }
};

// 2. Save to inventory using SetItem global function
await SetItem(grabbableCube, {context: 'script'});

// 3. Load to scene using global function
await LoadItem("RedGrabbableCube", "Scene", null, {context: 'script'});
```

#### IMPERATIVE Approach

```javascript
// Use global functions, not Change classes!

// 1. Create entity
const entity = await AddEntity("Scene", "RedGrabbableCube", {context: 'script'});

// 2. Add box mesh
await AddComponent(entity.id, "BanterBox", {context: 'script'});

// 3. Add material with red color (REQUIRED!)
await AddComponent(
  entity.id,
  "BanterMaterial",
  {
    context: 'script',
    color: { r: 1, g: 0, b: 0, a: 1 }
  }
);

// 4. Add collider for physics
await AddComponent(entity.id, "BoxCollider", {context: 'script'});

// 5. Add rigidbody for grabbable
await AddComponent(
  entity.id,
  "BanterRigidbody",
  {
    context: 'script',
    mass: 1,
    useGravity: true
  }
);

// 6. Add grabbable component
await AddComponent(
  entity.id,
  "BanterGrabbable",
  {
    context: 'script'
  }
);

// 7. Set position
await SetEntityProp(
  entity.id,
  "localPosition",
  { x: 2, y: 1, z: 0 },
  {context: 'script'}
);
```

### Key Differences Illustrated

| Aspect | DECLARATIVE | IMPERATIVE |
|--------|------------|------------|
| **Lines of code** | ~30 (mostly data) | ~25 (mostly operations) |
| **Operations** | 3 (define, save, load) | 7+ sequential commands |
| **Error handling** | Single point of failure | Multiple failure points |
| **Partial states** | Impossible (atomic) | Possible between commands |
| **Reusability** | Saved in inventory | Must re-run all commands |
| **Modification** | Replace entire structure | Add/change specific parts |
| **Debugging** | Inspect data structure | Trace command sequence |

### When Each Shines

**DECLARATIVE shines when:**
- You're defining a complete "prefab" or template
- The structure is known and fixed
- You want to share or reuse the object
- Atomic creation is important

**IMPERATIVE shines when:**
- You need to add components conditionally
- You're modifying an existing object
- Building interactively based on results
- Creating many variations programmatically

---

## Component Composition Patterns

**IMPORTANT**: All patterns show EVERY required component. When scripting, nothing is auto-added!

### Basic Primitive (Box/Sphere/Cylinder)

```javascript
{
  components: [
    { type: "BanterBox" },  // or BanterSphere, BanterCylinder
    {
      type: "BanterMaterial",  // MUST be explicitly added for visibility!
      properties: {
        color: { r: 1, g: 1, b: 1, a: 1 },
        shaderName: "Unlit/Diffuse",
        generateMipMaps: true,
        side: 0  // 0=Front, 1=Back, 2=Double
      }
    }
  ]
}
```

### Interactive Object (Grabbable)

```javascript
{
  components: [
    { type: "BanterBox" },            // The visual mesh
    { type: "BanterMaterial" },       // Required for visibility
    { type: "BoxCollider" },          // Required for physics/grabbing
    {
      type: "BanterRigidbody",        // Required for grabbable
      properties: {
        mass: 1,
        drag: 0.5,
        angularDrag: 0.5,
        useGravity: true
      }
    },
    { type: "BanterGrabbable" }       // The grab behavior itself
  ]
}
```

### GLTF Model with Scripts

```javascript
{
  components: [
    {
      type: "BanterGLTF",
      properties: {
        url: "https://cdn.example.com/model.glb",
        addColliders: true
      }
    },
    {
      type: "MonoBehavior",
      properties: {
        file: "CustomBehavior.js",
        vars: {
          speed: 1.0,
          enabled: true
        }
      }
    }
  ]
}
```

### Physics Object

```javascript
{
  components: [
    { type: "BanterSphere" },
    { type: "BanterMaterial" },
    { type: "SphereCollider" },
    {
      type: "BanterRigidbody",
      properties: {
        mass: 0.5,
        drag: 0.1,
        angularDrag: 0.05,
        useGravity: true
      }
    },
    {
      type: "BanterPhysicMaterial",
      properties: {
        bounciness: 0.8,
        frictionCombine: 0,
        bounceCombine: 3
      }
    }
  ]
}
```

### UI Panel

```javascript
{
  components: [
    {
      type: "BanterUIPanel",
      properties: {
        width: 400,
        height: 300,
        content: "<h1>Hello VR</h1><p>Interactive UI</p>"
      }
    },
    { type: "BoxCollider" }
  ]
}
```

---

## Code Injection Templates

### Template 1: Quick Primitive Creation (WITH Material!)

```javascript
// Complete primitive creation flow - INCLUDES REQUIRED MATERIAL
await mcp__chrome-devtools__evaluate_script({
  function: `async () => {
    // 1. Create entity using global function
    const entityName = "Cube_" + Date.now();
    const entity = await window.AddEntity(
      "Scene", entityName, { context: 'script' }
    );

    if (!entity) return { error: "Failed to create entity" };

    // 2. Add box component
    await window.AddComponent(
      entity.id, "BanterBox", { context: 'script' }
    );

    // 3. CRITICAL: Add material (required for visibility!)
    await window.AddComponent(
      entity.id,
      "BanterMaterial",
      {
        context: 'script',
        color: { r: 1, g: 0.5, b: 0.2, a: 1 },
        shaderName: "Unlit/Diffuse"
      }
    );

    // 4. Set position
    await window.SetEntityProp(
      entity.id, "localPosition", { x: 0, y: 2, z: 0 }, { context: 'script' }
    );

    return {
      success: true,
      entityId: entity.id,
      message: "Created box with material at (0, 2, 0)"
    };
  }`
});
```

### Template 2: Batch Object Creation (WITH Materials!)

```javascript
// Create multiple objects in a grid - ALL WITH MATERIALS
await mcp__chrome-devtools__evaluate_script({
  function: `async () => {
    const results = [];

    for (let x = 0; x < 3; x++) {
      for (let z = 0; z < 3; z++) {
        const name = \`GridObj_\${x}_\${z}\`;

        // Create entity using global function
        const entity = await window.AddEntity(
          "Scene", name, { context: 'script' }
        );

        if (entity) {
          // Add sphere
          await window.AddComponent(
            entity.id, "BanterSphere", { context: 'script' }
          );

          // CRITICAL: Add material with unique color per object
          await window.AddComponent(
            entity.id,
            "BanterMaterial",
            {
              context: 'script',
              color: {
                r: x / 2,      // Vary red by x position
                g: 0.5,
                b: z / 2,      // Vary blue by z position
                a: 1
              }
            }
          );

          // Position in grid
          await window.SetEntityProp(
            entity.id,
            "localPosition",
            { x: x * 2, y: 1, z: z * 2 },
            { context: 'script' }
          );

          results.push(entity.id);
        }
      }
    }

    return {
      success: true,
      created: results.length,
      entities: results,
      message: "Created grid of spheres with varied colors"
    };
  }`
});
```

### Template 3: Save Current Selection to Inventory

```javascript
// Save whatever is currently selected
await mcp__chrome-devtools__evaluate_script({
  function: `async () => {
    const selectedEntity = SM.selectedEntity;

    if (!selectedEntity) {
      return { error: "No entity selected" };
    }

    const itemName = selectedEntity.name + "_saved";

    // Use global function, not Change class
    const result = await window.SaveEntityItem(
      selectedEntity.id,
      itemName,
      null,  // root folder
      { context: 'script' }
    );

    return {
      success: result !== null,
      itemName: itemName,
      message: result ?
        \`Saved \${selectedEntity.name} to inventory as \${itemName}\` :
        "Failed to save entity"
    };
  }`
});
```

---

## Validation & Testing

### 1. Verify Entity Creation

```javascript
await mcp__chrome-devtools__evaluate_script({
  function: `() => {
    const entityId = "Scene/MyEntity";
    const entity = SM.getEntityById(entityId);

    return {
      exists: entity !== undefined,
      isActive: entity?.active,
      hasComponents: entity?.components?.length > 0,
      componentCount: entity?.components?.length || 0,
      componentTypes: entity?.components?.map(c => c.type) || []
    };
  }`
});
```

### 2. Check Component Properties

```javascript
await mcp__chrome-devtools__evaluate_script({
  function: `() => {
    const componentId = "BanterMaterial_12345";
    const component = SM.getEntityComponentById(componentId);

    return {
      exists: component !== undefined,
      type: component?.type,
      properties: component?.properties,
      initialized: component?._initialized
    };
  }`
});
```

### 3. Validate Inventory Item

```javascript
await mcp__chrome-devtools__evaluate_script({
  function: `() => {
    const itemName = "MyCustomObject";
    const item = inventory.items[itemName];

    return {
      exists: item !== undefined,
      type: item?.itemType,
      hasData: item?.data !== undefined,
      componentCount: item?.data?.components?.length || 0,
      author: item?.author,
      created: item?.created ? new Date(item.created).toISOString() : null
    };
  }`
});
```

### 4. Take Visual Snapshot

```javascript
// Use MCP to verify visually
await mcp__chrome-devtools__take_snapshot();
// Look for your entity in the hierarchy
```

---

## Common Pitfalls & Solutions

### Pitfall 1: Transform Component in New Format

**Wrong:**
```javascript
components: [
  {
    type: "Transform",  // ‚ùå Transform is NOT a component
    properties: { localPosition: { x: 1, y: 2, z: 3 } }
  }
]
```

**Correct:**
```javascript
{
  transform: {  // ‚úÖ Transform at entity level
    localPosition: { x: 1, y: 2, z: 3 },
    localRotation: { x: 0, y: 0, z: 0, w: 1 },
    localScale: { x: 1, y: 1, z: 1 }
  },
  components: [
    // Other components here
  ]
}
```

### Pitfall 2: Missing Component IDs

**Problem:** Components need unique IDs for tracking
**Solution:** Let the system auto-generate them or provide unique ones

```javascript
// Let system generate
const change = new ComponentAddChange(entityId, componentType);

// Or provide your own
componentProperties: {
  id: `${componentType}_${Math.floor(Math.random() * 99999)}`
}
```

### Pitfall 3: Invalid Entity Paths

**Wrong:**
```javascript
"MyEntity"  // ‚ùå Missing parent path
```

**Correct:**
```javascript
"Scene/MyEntity"  // ‚úÖ Full hierarchical path
"Scene/Parent/Child"  // ‚úÖ Nested path
```

### Pitfall 4: Component Dependencies

**Problem:** Some components require others to function
**Solution:** Add required components or use bundled types

```javascript
// BanterGrabbable needs collider and rigidbody
components: [
  { type: "BanterBox" },
  { type: "BoxCollider" },  // Required for grabbing
  { type: "BanterRigidbody" },  // Required for physics
  { type: "BanterGrabbable" }
]
```

### Pitfall 5: Async Operation Timing

**Problem:** Operations may not complete immediately
**Solution:** Always await changes and verify

```javascript
const change = new EntityAddChange(parentId, name);
const entity = await change.apply();  // Wait for completion

// Verify before proceeding
if (!entity) {
  throw new Error("Entity creation failed");
}
```

---

## Quick Reference

### Essential Global Objects & Functions

```javascript
// Scene Management
SM                    // Scene Manager
SM.scene             // BanterScript scene
SM.getEntityById()   // Get entity by path
SM.selectedEntity    // Currently selected
scene                // Unity scene object
scene.objects        // All GameObjects
scene.spaceState     // Space properties

// Global Command Functions (Use these, not ChangeTypes.classes!)
AddEntity(parentId, name, options)           // Create entity
RemoveEntity(entityId, options)              // Delete entity
MoveEntity(entityId, newParentId, options)   // Move entity
CloneEntity(entityId, options)               // Clone entity
SetEntityProp(entityId, prop, value, options) // Set entity property

AddComponent(entityId, componentType, options)    // Add component
RemoveComponent(componentId, options)             // Remove component
SetComponentProp(componentId, prop, value, options) // Set component property

SetItem(itemData, options)                          // Save item to inventory (NEW!)
SaveEntityItem(entityId, itemName, folder, options) // Save entity to inventory
LoadItem(itemName, parentId, position, options)     // Load from inventory
DeleteItem(itemName, options)                       // Delete from inventory

SetSpaceProp(prop, value, isProtected, options)     // Set space property

// Support Systems
inventory            // Inventory system
inventory.items      // All saved items
ComponentRegistry    // Component definitions
ComponentRegistry.list()
ComponentRegistry.getByCategory()

// Always pass {context: 'script'} in options!
```

### Common Component Types

**Geometry/Meshes:**
- `BanterBox`, `BanterSphere`, `BanterCylinder`, `BanterPlane`
- `BanterTorus`, `BanterCone`, `BanterRing`
- `BanterText` - 3D text
- `BanterGeometry` - Generic geometry with parameters

**Materials:**
- `BanterMaterial` - Visual material
- `BanterPhysicMaterial` - Physics properties

**Physics:**
- `BanterRigidbody` - Physics simulation
- `BoxCollider`, `SphereCollider`, `CapsuleCollider`, `MeshCollider`
- Joints: `HingeJoint`, `FixedJoint`, `SpringJoint`, `ConfigurableJoint`

**Behaviors:**
- `BanterGrabbable` - VR grabbable
- `BanterSyncedObject` - Multi-user sync
- `BanterColliderEvents` - Collision detection
- `MonoBehavior` - Custom scripts

**Media:**
- `BanterGLTF` - 3D models
- `BanterAudioSource` - Sound playback
- `BanterVideoPlayer` - Video playback

**Special:**
- `BanterMirror` - Reflective surface
- `BanterPortal` - Teleport portal
- `BanterUIPanel` - HTML UI
- `BanterBrowser` - Web browser

### Important Note on Methods

**For Chrome DevTools agents:**
- Use global functions like `AddEntity()`, `AddComponent()`, etc.
- Do NOT use `ChangeTypes.classes.*` - those are for internal undo/redo
- Always pass `{context: 'script'}` to identify agent operations

**Shell commands (for reference only):**
```
These are typed directly in the inspector shell, not used in scripts:
add_entity Scene MyEntity
remove_entity Scene/MyEntity
add_component Scene/Entity BanterBox
set_entity_property Scene/Entity localPosition {x:0,y:1,z:0}
```

---

## Best Practices Summary

1. **EXPLICITLY ADD ALL COMPONENTS** - When scripting, nothing is automatic!
2. **Always add BanterMaterial with geometry** - Without it, objects are invisible
3. **Validate before proceeding** - Check entities exist before adding components
4. **Use inventory for complex objects** - Easier to manage and reuse
5. **Let system generate IDs** - Avoid ID conflicts
6. **Understand component dependencies** - Must manually satisfy all dependencies
7. **Use proper paths** - Always include parent in entity paths (Scene/Entity)
8. **Await async operations** - Ensure changes complete before continuing
9. **Test incrementally** - Build objects step by step, validating each stage
10. **Use visual verification** - Take snapshots to confirm construction
11. **Handle errors gracefully** - Check return values and handle failures
12. **Document your objects** - Add descriptions to inventory items

---

## Conclusion

This guide establishes a paradigm-first approach to object construction in the Banter VR platform.

### The Fundamental Choice

Before writing any code, you must choose your paradigm:

**DECLARATIVE (Inventory)**
- "I want to describe WHAT should exist"
- Best for: Templates, prefabs, known structures
- Approach: Define ‚Üí Save ‚Üí Load

**IMPERATIVE (Change Commands)**
- "I want to control HOW it's built"
- Best for: Modifications, dynamic construction, experiments
- Approach: Command ‚Üí Command ‚Üí Command

### The Five Universal Truths

1. **Use global functions, not Change classes** - `AddEntity()` not `ChangeTypes.classes.EntityAddChange`
2. **Choose your paradigm FIRST** - Don't mix approaches in a single task
3. **Explicit is non-negotiable** - When scripting, YOU add EVERY component
4. **No auto-imports in scripting** - The `{source: "ui"}` magic is UI-only
5. **Materials are mandatory** - Geometry without BanterMaterial = invisible

### Decision Framework

```
Are you building something new?
  ‚Üí Do you know the complete structure? ‚Üí DECLARATIVE
  ‚Üí Do you need to build conditionally? ‚Üí IMPERATIVE

Are you modifying something?
  ‚Üí IMPERATIVE (no other choice)

Are you creating templates?
  ‚Üí DECLARATIVE (for reusability)

Are you experimenting?
  ‚Üí Will you reuse it? ‚Üí DECLARATIVE
  ‚Üí Just testing? ‚Üí IMPERATIVE
```

### Final Word

Three critical implementation rules for Chrome DevTools agents:

1. **Always use global functions** (`AddEntity`, `AddComponent`, etc.) - never the Change classes
2. **Always pass `{context: 'script'}`** in the options parameter
3. **Always add all components explicitly** - nothing is automatic in script context

The distinction between declarative and imperative construction is not about complexity or simplicity - it's about whether you're defining an end state or a process. Master both paradigms, choose deliberately, and execute with precision.

**Remember: In scripting, you have complete control and complete responsibility.**